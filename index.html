<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>高精度地震震度予測システム</title>

<!-- Tailwind CDN for styling (keeps original Tailwind classes) -->
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

<style>
  body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  .switch { width: 44px; height: 24px; background: #d1d5db; border-radius: 999px; position: relative; display:inline-block; vertical-align: middle; }
  .switch > .knob { width:20px;height:20px;background:#fff;border-radius:999px;position:absolute;left:2px;top:2px;transition: all .2s;box-shadow:0 1px 3px rgba(0,0,0,.2); }
  .switch.on{background:#2563eb;}
  .switch.on > .knob{transform: translateX(20px);}
  .icon { vertical-align: -0.15em; }
</style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
  <div id="app"></div>

  <!-- Load libs from CDN:
       - Preact (preact/compat compatible API)
       - htm (JSX-like templates in runtime)
       - lucide (icons)
       - d3 v7
  -->
  <script src="https://unpkg.com/preact@10.16.0/dist/preact.umd.js"></script>
  <script src="https://unpkg.com/preact@10.16.0/hooks/dist/hooks.umd.js"></script>
  <script src="https://unpkg.com/htm@3.1.1/dist/htm.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://unpkg.com/lucide@0.263.0/dist/lucide.min.js"></script>

  <script>
  (function(){
    const { h, render } = preact;
    const { useState, useEffect, useRef } = preactHooks;
    const html = htm.bind(h);

    function Icon(name, props = {}) {
      try {
        const svg = lucide.createIcon(name, Object.assign({width:24,height:24,class:'icon'}, props));
        const wrapper = document.createElement('span');
        wrapper.innerHTML = svg.toString();
        return h('span', { dangerouslySetInnerHTML: { __html: wrapper.innerHTML } });
      } catch(e) {
        return h('span', null);
      }
    }

    const prefectures = [
      { code: 1, name: '北海道', city: '札幌', lat: 43.0642, lon: 141.3469 },
      { code: 2, name: '青森県', city: '青森', lat: 40.8244, lon: 140.7400 },
      { code: 3, name: '岩手県', city: '盛岡', lat: 39.7036, lon: 141.1527 },
      { code: 4, name: '宮城県', city: '仙台', lat: 38.2682, lon: 140.8694 },
      { code: 5, name: '秋田県', city: '秋田', lat: 39.7186, lon: 140.1024 },
      { code: 6, name: '山形県', city: '山形', lat: 38.2404, lon: 140.3633 },
      { code: 7, name: '福島県', city: '福島', lat: 37.7503, lon: 140.4676 },
      { code: 8, name: '茨城県', city: '水戸', lat: 36.3418, lon: 140.4468 },
      { code: 9, name: '栃木県', city: '宇都宮', lat: 36.5658, lon: 139.8836 },
      { code: 10, name: '群馬県', city: '前橋', lat: 36.3911, lon: 139.0608 },
      { code: 11, name: '埼玉県', city: 'さいたま', lat: 35.8617, lon: 139.6455 },
      { code: 12, name: '千葉県', city: '千葉', lat: 35.6074, lon: 140.1065 },
      { code: 13, name: '東京都', city: '東京', lat: 35.6895, lon: 139.6917 },
      { code: 14, name: '神奈川県', city: '横浜', lat: 35.4437, lon: 139.6380 },
      { code: 15, name: '新潟県', city: '新潟', lat: 37.9026, lon: 139.0232 },
      { code: 16, name: '富山県', city: '富山', lat: 36.6953, lon: 137.2113 },
      { code: 17, name: '石川県', city: '金沢', lat: 36.5946, lon: 136.6256 },
      { code: 18, name: '福井県', city: '福井', lat: 36.0652, lon: 136.2216 },
      { code: 19, name: '山梨県', city: '甲府', lat: 35.6642, lon: 138.5684 },
      { code: 20, name: '長野県', city: '長野', lat: 36.6513, lon: 138.1810 },
      { code: 21, name: '岐阜県', city: '岐阜', lat: 35.3912, lon: 136.7223 },
      { code: 22, name: '静岡県', city: '静岡', lat: 34.9769, lon: 138.3831 },
      { code: 23, name: '愛知県', city: '名古屋', lat: 35.1815, lon: 136.9066 },
      { code: 24, name: '三重県', city: '津', lat: 34.7303, lon: 136.5086 },
      { code: 25, name: '滋賀県', city: '大津', lat: 35.0045, lon: 135.8686 },
      { code: 26, name: '京都府', city: '京都', lat: 35.0116, lon: 135.7681 },
      { code: 27, name: '大阪府', city: '大阪', lat: 34.6937, lon: 135.5023 },
      { code: 28, name: '兵庫県', city: '神戸', lat: 34.6901, lon: 135.1955 },
      { code: 29, name: '奈良県', city: '奈良', lat: 34.6851, lon: 135.8329 },
      { code: 30, name: '和歌山県', city: '和歌山', lat: 34.2261, lon: 135.1675 },
      { code: 31, name: '鳥取県', city: '鳥取', lat: 35.5014, lon: 134.2382 },
      { code: 32, name: '島根県', city: '松江', lat: 35.4723, lon: 133.0505 },
      { code: 33, name: '岡山県', city: '岡山', lat: 34.6617, lon: 133.9350 },
      { code: 34, name: '広島県', city: '広島', lat: 34.3965, lon: 132.4596 },
      { code: 35, name: '山口県', city: '山口', lat: 34.1861, lon: 131.4706 },
      { code: 36, name: '徳島県', city: '徳島', lat: 34.0658, lon: 134.5594 },
      { code: 37, name: '香川県', city: '高松', lat: 34.3401, lon: 134.0434 },
      { code: 38, name: '愛媛県', city: '松山', lat: 33.8416, lon: 132.7657 },
      { code: 39, name: '高知県', city: '高知', lat: 33.5597, lon: 133.5311 },
      { code: 40, name: '福岡県', city: '福岡', lat: 33.6064, lon: 130.4181 },
      { code: 41, name: '佐賀県', city: '佐賀', lat: 33.2494, lon: 130.2988 },
      { code: 42, name: '長崎県', city: '長崎', lat: 32.7503, lon: 129.8777 },
      { code: 43, name: '熊本県', city: '熊本', lat: 32.7898, lon: 130.7417 },
      { code: 44, name: '大分県', city: '大分', lat: 33.2382, lon: 131.6126 },
      { code: 45, name: '宮崎県', city: '宮崎', lat: 31.9077, lon: 131.4202 },
      { code: 46, name: '鹿児島県', city: '鹿児島', lat: 31.5602, lon: 130.5581 },
      { code: 47, name: '沖縄県', city: '那覇', lat: 26.2124, lon: 127.6809 }
    ];

    function getIntensityColor(scale) {
      const colors = {
        '0': '#C0C0C0', '1': '#3B82F6', '2': '#10B981',
        '3': '#FBBF24', '4': '#F97316', '5弱': '#EF4444',
        '5強': '#DC2626', '6弱': '#B91C1C', '6強': '#991B1B', '7': '#7C3AED'
      };
      return colors[scale] || '#C0C0C0';
    }
    function getIntensityScale(intensity) {
      if (intensity < 0.5) return '0';
      if (intensity < 1.5) return '1';
      if (intensity < 2.5) return '2';
      if (intensity < 3.5) return '3';
      if (intensity < 4.5) return '4';
      if (intensity < 5.0) return '5弱';
      if (intensity < 5.5) return '5強';
      if (intensity < 6.0) return '6弱';
      if (intensity < 6.5) return '6強';
      return '7';
    }
    function calculateAmplificationFromAVS30(avs30Value){
      if (avs30Value >= 400) return 1.0;
      const amp = Math.pow(400 / avs30Value, 0.6);
      return Math.min(amp, 3.0);
    }
    function estimateAVS30FromLocation(lat, lon){
      const isCoastalLowland = (lat < 36 && lon > 139.5 && lon < 140.5) ||
                                (lat > 34 && lat < 35 && lon > 135 && lon < 136) ||
                                (lat < 34 && lon > 130 && lon < 132);
      const isAlluvialPlain = (lat > 35 && lat < 37 && lon > 138.5 && lon < 140) ||
                              (lat > 33 && lat < 34 && lon > 130 && lon < 131);
      const isDiluvialPlateau = (lat > 35.5 && lat < 36.5 && lon > 139 && lon < 140.5);
      const isMountainous = (lat > 36 && lon < 138) || (lat > 35 && lon > 141);
      if (isCoastalLowland) return { avs30: 180, type: '沖積低地（軟弱）' };
      if (isAlluvialPlain) return { avs30: 220, type: '沖積平野' };
      if (isDiluvialPlateau) return { avs30: 280, type: '洪積台地' };
      if (isMountainous) return { avs30: 450, type: '丘陵・山地（硬質）' };
      return { avs30: 300, type: '第三紀丘陵' };
    }
    function toRad(deg){return deg*Math.PI/180;}
    function calculateDistance(lat1, lon1, lat2, lon2){
      const latAvg = (lat1+lat2)/2;
      const a=6378137, b=6356752.314245;
      const e2=(a*a-b*b)/(a*a);
      const W=Math.sqrt(1-e2*Math.sin(toRad(latAvg))**2);
      const M=(a*(1-e2))/(W**3);
      const N=a/W;
      const dLat=toRad(lat2-lat1);
      const dLon=toRad(lon2-lon1);
      const distance=Math.sqrt((M*dLat)**2 + (N*Math.cos(toRad(latAvg))*dLon)**2);
      return distance/1000;
    }
    function calculateHypocentralDistance(surfaceDistance, depth){ return Math.sqrt(surfaceDistance**2 + depth**2); }
    function calculateSWaveArrivalTime(distance, depth, targetAvs30){
      const hypoDistance = calculateHypocentralDistance(distance, depth);
      const crustVs = 3.5;
      const surfaceThickness = 0.03;
      const surfaceVs = targetAvs30 / 1000;
      const surfaceTime = surfaceThickness / surfaceVs;
      const crustTime = (hypoDistance - surfaceThickness) / crustVs;
      return crustTime + surfaceTime;
    }
    function predictPGV(M, X, depth){
      const Mw = M; const D = X;
      const depthFactor = 0.0038 * depth;
      const logPGV = 0.58 * Mw + depthFactor - 1.29 - Math.log10(D + 0.0028 * Math.pow(10, 0.5 * Mw)) - 0.002 * D;
      return Math.pow(10, logPGV);
    }
    function pgvToIntensity(pgv, amplification){
      const adjustedPGV = pgv * amplification;
      const I = 2.68 + 1.72 * Math.log10(Math.max(adjustedPGV, 1e-6));
      return Math.max(0, I);
    }

    function App() {
      const [magnitude, setMagnitude] = useState(7.0);
      const [depth, setDepth] = useState(10);
      const [epicenterLat, setEpicenterLat] = useState(35.6895);
      const [epicenterLon, setEpicenterLon] = useState(139.6917);
      const [targetLat, setTargetLat] = useState(35.7);
      const [targetLon, setTargetLon] = useState(139.7);
      const [amplificationFactor, setAmplificationFactor] = useState(1.6);
      const [autoAmplification, setAutoAmplification] = useState(true);
      const [geologyType, setGeologyType] = useState('計算中...');
      const [avs30, setAvs30] = useState(300);
      const [predictedIntensity, setPredictedIntensity] = useState(null);
      const [isSimulating, setIsSimulating] = useState(false);
      const [simulationTime, setSimulationTime] = useState(0);
      const [simulationSpeed, setSimulationSpeed] = useState(1);
      const [prefectureIntensities, setPrefectureIntensities] = useState({});
      const [japanData, setJapanData] = useState(null);
      const svgRef = useRef(null);
      const animationRef = useRef(null);

      useEffect(() => {
        let mounted = true;
        (async ()=>{
          const sources = [
            'https://raw.githubusercontent.com/niiyz/JapanCityGeoJson/master/geojson/prefectures.json',
            'https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson'
          ];
          let data = null;
          for (const s of sources) {
            try {
              const r = await fetch(s);
              if (r.ok) { data = await r.json(); break; }
            } catch(e) { console.warn('geo load failed', s); }
          }
          if (!data) {
            data = { type: 'FeatureCollection', features: prefectures.map(pref => {
              const points=[]; const radius=0.5;
              for (let i=0;i<=360;i+=10) {
                const rad = i*Math.PI/180;
                const lat = pref.lat + radius*Math.sin(rad);
                const lon = pref.lon + radius*Math.cos(rad);
                points.push([lon, lat]);
              }
              return { type:'Feature', properties:{name:pref.name}, geometry:{type:'Polygon', coordinates:[points]} };
            })};
          }
          if (mounted) setJapanData(data);
        })();
        return ()=>{ mounted=false; }
      }, []);

      useEffect(()=>{
        if (!autoAmplification) return;
        const d = estimateAVS30FromLocation(targetLat, targetLon);
        setAvs30(d.avs30); setGeologyType(d.type);
        setAmplificationFactor(calculateAmplificationFromAVS30(d.avs30));
      }, [targetLat, targetLon, autoAmplification]);

      useEffect(()=>{
        const surfaceDist = calculateDistance(epicenterLat, epicenterLon, targetLat, targetLon);
        const hypoDist = calculateHypocentralDistance(surfaceDist, depth);
        const pgv = predictPGV(magnitude, hypoDist, depth);
        const intensity = pgvToIntensity(pgv, amplificationFactor);
        setPredictedIntensity({ value:intensity, scale:getIntensityScale(intensity), pgv, surfaceDistance: surfaceDist, hypoDistance: hypoDist });
      }, [magnitude, depth, epicenterLat, epicenterLon, targetLat, targetLon, amplificationFactor]);

      useEffect(()=>{
        if (!japanData) return;
        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();
        const width = 850, height = 680;
        svg.attr('viewBox','0 0 850 680').style('max-height','800px');
        svg.append('rect').attr('width',width).attr('height',height).attr('fill','#e8f4f8');
        const projection = d3.geoMercator().center([137,38]).scale(1400).translate([width/2,height/2]);
        const path = d3.geoPath().projection(projection);
        const g = svg.append('g');
        g.selectAll('path').data(japanData.features).enter().append('path')
          .attr('d', path)
          .attr('fill', d => {
            const prefName = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
            const intensity = prefectureIntensities[prefName];
            return intensity ? getIntensityColor(intensity.scale) : '#f0f0f0';
          })
          .attr('stroke','#333').attr('stroke-width',0.5)
          .attr('opacity', d => {
            const prefName = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
            const intensity = prefectureIntensities[prefName];
            return intensity ? 0.9 : 0.5;
          })
          .style('transition','all 0.3s');

        prefectures.forEach(pref => {
          const intensity = prefectureIntensities[pref.name];
          if (!intensity) return;
          const coords = projection([pref.lon, pref.lat]);
          g.append('circle').attr('cx', coords[0]).attr('cy', coords[1]).attr('r',8)
            .attr('fill', getIntensityColor(intensity.scale)).attr('stroke','#fff').attr('stroke-width',1.5);
          g.append('text').attr('x', coords[0]).attr('y', coords[1]-12).attr('text-anchor','middle')
            .attr('font-weight','bold').attr('font-size','12px').attr('fill', getIntensityColor(intensity.scale)).text(intensity.scale);
        });

        const epicenterCoords = projection([epicenterLon, epicenterLat]);
        g.append('circle').attr('cx', epicenterCoords[0]).attr('cy', epicenterCoords[1]).attr('r',10)
          .attr('fill','#ff0000').attr('stroke','#fff').attr('stroke-width',2);
        g.append('text').attr('x', epicenterCoords[0]).attr('y', epicenterCoords[1]-15).attr('text-anchor','middle')
          .attr('font-weight','bold').attr('font-size','14px').attr('fill','#ff0000').text('★震源');

      }, [japanData, prefectureIntensities, epicenterLat, epicenterLon]);

      function calculateAllPrefectureIntensities(currentTime) {
        const intensities = {};
        prefectures.forEach(pref => {
          const distance = calculateDistance(epicenterLat, epicenterLon, pref.lat, pref.lon);
          const prefData = estimateAVS30FromLocation(pref.lat, pref.lon);
          const arrivalTime = calculateSWaveArrivalTime(distance, depth, prefData.avs30);
          if (currentTime >= arrivalTime) {
            const hypoDist = calculateHypocentralDistance(distance, depth);
            const amp = calculateAmplificationFromAVS30(prefData.avs30);
            const pgv = predictPGV(magnitude, hypoDist, depth);
            const intensity = pgvToIntensity(pgv, amp);
            intensities[pref.name] = {
              value: intensity,
              scale: getIntensityScale(intensity),
              arrivalTime,
              distance,
              avs30: prefData.avs30
            };
          }
        });
        return intensities;
      }

      function startSimulation(){
        if (isSimulating) return;
        setIsSimulating(true);
        const start = performance.now();
        const loop = () => {
          const elapsed = (performance.now() - start) / 1000;
          const simTime = elapsed * simulationSpeed;
          setSimulationTime(simTime);
          setPrefectureIntensities(calculateAllPrefectureIntensities(simTime));
          const maxDistance = Math.max(...prefectures.map(p=>calculateDistance(epicenterLat, epicenterLon, p.lat, p.lon)));
          const maxTime = calculateSWaveArrivalTime(maxDistance, depth, 450);
          if (simTime < maxTime + 10) {
            animationRef.current = requestAnimationFrame(loop);
          } else {
            setIsSimulating(false);
          }
        };
        animationRef.current = requestAnimationFrame(loop);
      }
      function stopSimulation(){ setIsSimulating(false); if (animationRef.current) cancelAnimationFrame(animationRef.current); }
      function resetSimulation(){ stopSimulation(); setSimulationTime(0); setPrefectureIntensities({}); }

      return html`
        <div class="min-h-screen">
          <div class="max-w-7xl mx-auto">
            <div class="bg-white rounded-lg shadow-xl p-6 mb-6">
              <div class="flex items-center gap-3 mb-4">
                <span>${Icon('activity',{width:32})}</span>
                <h1 class="text-3xl font-bold text-gray-800">高精度地震震度予測システム</h1>
              </div>
              <p class="text-gray-600 mb-4">GeoJSONデータを使用した、リアルタイム震度分布シミュレーション</p>
            </div>

            <div class="grid lg:grid-cols-3 gap-6 mb-6">
              <div class="bg-white rounded-lg shadow-lg p-6">
                <div class="flex items-center gap-2 mb-4">
                  <span>${Icon('map-pin')}</span>
                  <h2 class="text-xl font-bold text-gray-800">震源設定</h2>
                </div>

                <div class="space-y-4">
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">マグニチュード: ${magnitude.toFixed(1)}</label>
                    <input type="range" min="4.0" max="9.0" step="0.1" value=${magnitude} onInput=${e => setMagnitude(parseFloat(e.target.value))} class="w-full"/>
                  </div>

                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">震源深さ: ${depth}km</label>
                    <input type="range" min="0" max="100" step="5" value=${depth} onInput=${e => setDepth(parseInt(e.target.value))} class="w-full"/>
                  </div>

                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="block text-sm font-medium text-gray-700 mb-1">緯度</label>
                      <input type="number" step="0.01" value=${targetLat} onInput=${e => setTargetLat(parseFloat(e.target.value))} class="w-full px-2 py-1 border border-gray-300 rounded text-sm"/>
                    </div>
                    <div>
                      <label class="block text-sm font-medium text-gray-700 mb-1">経度</label>
                      <input type="number" step="0.01" value=${targetLon} onInput=${e => setTargetLon(parseFloat(e.target.value))} class="w-full px-2 py-1 border border-gray-300 rounded text-sm"/>
                    </div>
                  </div>

                  <div class="border-t pt-3">
                    <div class="flex items-center justify-between mb-2">
                      <label class="text-sm font-medium text-gray-700">地層データ自動計算</label>
                      <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" checked=${autoAmplification} onChange=${e => setAutoAmplification(e.target.checked)} class="sr-only" />
                        <div class=${'switch ' + (autoAmplification ? 'on' : '')}><div class="knob"></div></div>
                      </label>
                    </div>

                    <div class="bg-green-50 p-3 rounded-md text-sm">
                      <p class="text-green-800 font-medium">地質: ${geologyType}</p>
                      <p class="text-green-800">AVS30: ${avs30} m/s</p>
                      <p class="text-green-800">増幅率: ${amplificationFactor.toFixed(2)}</p>
                    </div>
                  </div>
                </div>
              </div>

              ${predictedIntensity && html`
              <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">地点予測結果</h2>
                <div style="background-color:${getIntensityColor(predictedIntensity.scale)}20" class="rounded-lg p-6 text-center mb-4">
                  <div class="text-6xl font-bold" style="color:${getIntensityColor(predictedIntensity.scale)}">${predictedIntensity.scale}</div>
                  <p class="text-sm text-gray-600 mt-2">計測震度: ${predictedIntensity.value.toFixed(2)}</p>
                </div>
                <div class="space-y-2 text-sm">
                  <div class="flex justify-between"><span class="text-gray-600">震央距離:</span><span class="font-semibold">${predictedIntensity.surfaceDistance.toFixed(1)} km</span></div>
                  <div class="flex justify-between"><span class="text-gray-600">予測PGV:</span><span class="font-semibold">${predictedIntensity.pgv.toFixed(1)} cm/s</span></div>
                </div>
              </div>`}

            </div>

            <div class="bg-white rounded-lg shadow-xl p-6 mb-6">
              <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">日本地図 震度分布シミュレーション</h2>
                <div class="flex gap-2 items-center">
                  <select value=${simulationSpeed} onChange=${e=>setSimulationSpeed(parseFloat(e.target.value))} class="px-3 py-2 border border-gray-300 rounded-md text-sm">
                    <option value="1">1倍速（実時間）</option>
                    <option value="2">2倍速</option>
                    <option value="5">5倍速</option>
                    <option value="10">10倍速</option>
                  </select>
                  <button onClick=${startSimulation} class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md flex items-center gap-2 transition"> ${Icon('play')} 開始</button>
                  <button onClick=${stopSimulation} class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md flex items-center gap-2 transition"> ${Icon('pause')} 停止</button>
                  <button onClick=${resetSimulation} class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md flex items-center gap-2 transition"> ${Icon('rotate-ccw')} リセット</button>
                </div>
              </div>

              <div class="bg-gray-100 rounded-lg p-4 mb-4">
                <div class="flex justify-between items-center">
                  <span class="text-lg font-semibold">経過時間: ${simulationTime.toFixed(1)}秒</span>
                  <span class="text-sm text-gray-600">到達地域数: ${Object.keys(prefectureIntensities).length} / 47</span>
                </div>
              </div>

              <div class="relative bg-white rounded-lg p-4 border border-gray-300">
                <div style="min-height: 420px;">
                  <svg ref=${svgRef} id="svgMap" class="w-full h-auto" viewBox="0 0 850 680"></svg>
                </div>
              </div>

              <div class="grid md:grid-cols-2 gap-4 mt-4">
                <div class="bg-gray-50 rounded-lg p-4">
                  <h3 class="font-bold mb-2">到達済み地域（到達順）</h3>
                  <div class="space-y-1 max-h-64 overflow-y-auto">
                    ${Object.entries(prefectureIntensities).sort((a,b)=>a[1].arrivalTime-b[1].arrivalTime).map(([name,data]) => html`
                      <div key=${name} class="flex justify-between items-center p-2 bg-white rounded text-xs">
                        <span class="font-medium">${name}</span>
                        <div class="flex items-center gap-2">
                          <span class="text-gray-600">${data.arrivalTime.toFixed(1)}s</span>
                          <span class="text-gray-500">AVS30:${data.avs30}</span>
                          <span class="font-bold px-2 py-1 rounded" style="background:${getIntensityColor(data.scale)}30;color:${getIntensityColor(data.scale)}">震度${data.scale}</span>
                        </div>
                      </div>`)}
                  </div>
                </div>

                <div class="bg-gray-50 rounded-lg p-4">
                  <h3 class="font-bold mb-2">震度凡例</h3>
                  <div class="grid grid-cols-2 gap-2">
                    ${['0','1','2','3','4','5弱','5強','6弱','6強','7'].map(scale => html`
                      <div key=${scale} class="flex items-center gap-2 p-2 bg-white rounded text-sm">
                        <div style="width:24px;height:24px;background:${getIntensityColor(scale)};border-radius:4px"></div>
                        <span>震度${scale}</span>
                      </div>`)}
                  </div>
                </div>
              </div>

            </div>

            <div class="bg-white rounded-lg shadow-lg p-6">
              <h3 class="text-lg font-bold text-gray-800 mb-3">データソースと計算手法</h3>
              <div class="grid md:grid-cols-2 gap-4 text-sm text-gray-600">
                <div>
                  <h4 class="font-semibold text-gray-800 mb-2">地図データ</h4>
                  <ul class="list-disc list-inside space-y-1">
                    <li>GeoJSON形式の日本地図（GitHub提供）</li>
                    <li>D3.js geoMercator投影法でSVG描画</li>
                    <li>47都道府県の境界線を正確に描画</li>
                    <li>フォールバック：簡略化した円形地図</li>
                  </ul>
                </div>
                <div>
                  <h4 class="font-semibold text-gray-800 mb-2">震度予測</h4>
                  <ul class="list-disc list-inside space-y-1">
                    <li>距離減衰式ベースの PGV 予測</li>
                    <li>AVS30 に基づく地盤増幅率</li>
                    <li>リアルタイム到達時間計算</li>
                  </ul>
                </div>
              </div>
            </div>

          </div>
        </div>
      `;
    }

    render(h(App, {}), document.getElementById('app'));
  })();
  </script>
</body>
</html>

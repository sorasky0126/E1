<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>高精度地震震度予測システム（改良版）</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  .switch { width: 44px; height: 24px; background: #d1d5db; border-radius: 999px; position: relative; display:inline-block; vertical-align: middle; }
  .switch > .knob { width:20px;height:20px;background:#fff;border-radius:999px;position:absolute;left:2px;top:2px;transition: all .2s;box-shadow:0 1px 3px rgba(0,0,0,.2); }
  .switch.on{background:#2563eb;}
  .switch.on > .knob{transform: translateX(20px);}
  .icon { vertical-align: -0.15em; }
  /* マーカー小型化 */
  .epicenter-marker { r: 6; } /* SVG circle r 属性は JS で設定 */
  .pref-marker { r: 4; }
  /* マップ領域の最小高さ確保 */
  #svgMap { max-height: 760px; width: 100%; height: auto; display:block; }
  .small-label { font-size: 11px; }
</style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
  <div id="app"></div>

  <!-- ライブラリ -->
  <script src="https://unpkg.com/preact@10.16.0/dist/preact.umd.js"></script>
  <script src="https://unpkg.com/preact@10.16.0/hooks/dist/hooks.umd.js"></script>
  <script src="https://unpkg.com/htm@3.1.1/dist/htm.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://unpkg.com/lucide@0.263.0/dist/lucide.min.js"></script>

  <script>
  (function(){
    const { h, render } = preact;
    const { useState, useEffect, useRef } = preactHooks;
    const html = htm.bind(h);

    function Icon(name, props = {}) {
      try {
        const svg = lucide.createIcon(name, Object.assign({width:24,height:24,class:'icon'}, props));
        const wrapper = document.createElement('span');
        wrapper.innerHTML = svg.toString();
        return h('span', { dangerouslySetInnerHTML: { __html: wrapper.innerHTML } });
      } catch(e) {
        return h('span', null);
      }
    }

    const prefectures = [
      { code: 1, name: '北海道', city: '札幌', lat: 43.0642, lon: 141.3469 },
      { code: 2, name: '青森県', city: '青森', lat: 40.8244, lon: 140.7400 },
      { code: 3, name: '岩手県', city: '盛岡', lat: 39.7036, lon: 141.1527 },
      { code: 4, name: '宮城県', city: '仙台', lat: 38.2682, lon: 140.8694 },
      { code: 5, name: '秋田県', city: '秋田', lat: 39.7186, lon: 140.1024 },
      { code: 6, name: '山形県', city: '山形', lat: 38.2404, lon: 140.3633 },
      { code: 7, name: '福島県', city: '福島', lat: 37.7503, lon: 140.4676 },
      { code: 8, name: '茨城県', city: '水戸', lat: 36.3418, lon: 140.4468 },
      { code: 9, name: '栃木県', city: '宇都宮', lat: 36.5658, lon: 139.8836 },
      { code: 10, name: '群馬県', city: '前橋', lat: 36.3911, lon: 139.0608 },
      { code: 11, name: '埼玉県', city: 'さいたま', lat: 35.8617, lon: 139.6455 },
      { code: 12, name: '千葉県', city: '千葉', lat: 35.6074, lon: 140.1065 },
      { code: 13, name: '東京都', city: '東京', lat: 35.6895, lon: 139.6917 },
      { code: 14, name: '神奈川県', city: '横浜', lat: 35.4437, lon: 139.6380 },
      { code: 15, name: '新潟県', city: '新潟', lat: 37.9026, lon: 139.0232 },
      { code: 16, name: '富山県', city: '富山', lat: 36.6953, lon: 137.2113 },
      { code: 17, name: '石川県', city: '金沢', lat: 36.5946, lon: 136.6256 },
      { code: 18, name: '福井県', city: '福井', lat: 36.0652, lon: 136.2216 },
      { code: 19, name: '山梨県', city: '甲府', lat: 35.6642, lon: 138.5684 },
      { code: 20, name: '長野県', city: '長野', lat: 36.6513, lon: 138.1810 },
      { code: 21, name: '岐阜県', city: '岐阜', lat: 35.3912, lon: 136.7223 },
      { code: 22, name: '静岡県', city: '静岡', lat: 34.9769, lon: 138.3831 },
      { code: 23, name: '愛知県', city: '名古屋', lat: 35.1815, lon: 136.9066 },
      { code: 24, name: '三重県', city: '津', lat: 34.7303, lon: 136.5086 },
      { code: 25, name: '滋賀県', city: '大津', lat: 35.0045, lon: 135.8686 },
      { code: 26, name: '京都府', city: '京都', lat: 35.0116, lon: 135.7681 },
      { code: 27, name: '大阪府', city: '大阪', lat: 34.6937, lon: 135.5023 },
      { code: 28, name: '兵庫県', city: '神戸', lat: 34.6901, lon: 135.1955 },
      { code: 29, name: '奈良県', city: '奈良', lat: 34.6851, lon: 135.8329 },
      { code: 30, name: '和歌山県', city: '和歌山', lat: 34.2261, lon: 135.1675 },
      { code: 31, name: '鳥取県', city: '鳥取', lat: 35.5014, lon: 134.2382 },
      { code: 32, name: '島根県', city: '松江', lat: 35.4723, lon: 133.0505 },
      { code: 33, name: '岡山県', city: '岡山', lat: 34.6617, lon: 133.9350 },
      { code: 34, name: '広島県', city: '広島', lat: 34.3965, lon: 132.4596 },
      { code: 35, name: '山口県', city: '山口', lat: 34.1861, lon: 131.4706 },
      { code: 36, name: '徳島県', city: '徳島', lat: 34.0658, lon: 134.5594 },
      { code: 37, name: '香川県', city: '高松', lat: 34.3401, lon: 134.0434 },
      { code: 38, name: '愛媛県', city: '松山', lat: 33.8416, lon: 132.7657 },
      { code: 39, name: '高知県', city: '高知', lat: 33.5597, lon: 133.5311 },
      { code: 40, name: '福岡県', city: '福岡', lat: 33.6064, lon: 130.4181 },
      { code: 41, name: '佐賀県', city: '佐賀', lat: 33.2494, lon: 130.2988 },
      { code: 42, name: '長崎県', city: '長崎', lat: 32.7503, lon: 129.8777 },
      { code: 43, name: '熊本県', city: '熊本', lat: 32.7898, lon: 130.7417 },
      { code: 44, name: '大分県', city: '大分', lat: 33.2382, lon: 131.6126 },
      { code: 45, name: '宮崎県', city: '宮崎', lat: 31.9077, lon: 131.4202 },
      { code: 46, name: '鹿児島県', city: '鹿児島', lat: 31.5602, lon: 130.5581 },
      { code: 47, name: '沖縄県', city: '那覇', lat: 26.2124, lon: 127.6809 }
    ];

    // 地層クラス（9段階）: 名前, AVS30 範囲 (m/s), 代表値 (m/s)
    const geologyClasses = [
      { key:'A', name:'埋積軟泥層', min:0,   max:120,  rep:90 },
      { key:'B', name:'沖積砂泥層', min:120, max:180,  rep:150 },
      { key:'C', name:'沖積砂質層', min:180, max:240,  rep:210 },
      { key:'D', name:'沖積平野（密）', min:240, max:280, rep:260 },
      { key:'E', name:'洪積台地', min:280, max:320,  rep:300 },
      { key:'F', name:'砂礫・礫層', min:320, max:360,  rep:340 },
      { key:'G', name:'山地浅層', min:360, max:420,  rep:390 },
      { key:'H', name:'深層基盤（硬質）', min:420, max:1000, rep:500 },
      { key:'I', name:'人工盛土・埋立', min:0, max:150, rep:120 }
    ];

    function findGeologyClassByAvs(avs) {
      for (const g of geologyClasses) {
        if (avs >= g.min && avs < g.max) return g;
      }
      return geologyClasses[6]; // default
    }

    function getIntensityColor(scale) {
      const colors = {
        '0': '#C0C0C0', '1': '#3B82F6', '2': '#10B981',
        '3': '#FBBF24', '4': '#F97316', '5弱': '#EF4444',
        '5強': '#DC2626', '6弱': '#B91C1C', '6強': '#991B1B', '7': '#7C3AED'
      };
      return colors[scale] || '#C0C0C0';
    }
    function getIntensityScale(intensity) {
      if (intensity < 0.5) return '0';
      if (intensity < 1.5) return '1';
      if (intensity < 2.5) return '2';
      if (intensity < 3.5) return '3';
      if (intensity < 4.5) return '4';
      if (intensity < 5.0) return '5弱';
      if (intensity < 5.5) return '5強';
      if (intensity < 6.0) return '6弱';
      if (intensity < 6.5) return '6強';
      return '7';
    }

    // より詳細な AVS30 推定（位置ルールを強化）
    function estimateAVS30FromLocation(lat, lon) {
      // 基本傾向：沿岸低地=低AVS30、沖積平野=やや低、台地=中、丘陵/山地=高、人工盛土(都市域)も加味
      // 都市域の簡易判定（東京・横浜・大阪・名古屋・福岡近傍）
      const urbanCenters = [
        { lat:35.68, lon:139.76, radiusKm:50 }, // Tokyo area
        { lat:34.69, lon:135.50, radiusKm:40 }, // Osaka
        { lat:35.18, lon:136.91, radiusKm:30 }, // Nagoya
        { lat:33.59, lon:130.40, radiusKm:40 }  // Fukuoka
      ];
      const isUrban = urbanCenters.some(c => {
        const d = calculateDistance(lat, lon, c.lat, c.lon);
        return d <= c.radiusKm;
      });

      // 地形要素（簡易）：緯度経度のバンドと海岸接近度
      const nearCoast = (lon > 122 && lon < 153 && (Math.abs(lat - 35) < 6 || Math.abs(lat - 33) < 6)) && (Math.abs(lon - 139.7) < 3 || lon < 132);
      const isLowland = (lat < 36 && lon > 138 && lon < 141) || (lat > 34 && lat < 35 && lon > 134 && lon < 136);
      const isAlluvial = (lat > 35 && lat < 37 && lon > 138.5 && lon < 140) || (lat > 33 && lat < 34 && lon > 130 && lon < 131);
      const isPlateau = (lat > 35.5 && lat < 36.5 && lon > 137 && lon < 140.5);
      const isMountain = (lat > 36 && lon < 139) || lat > 38 || lon < 132;

      // 基本 AVS30 値（m/s）
      let avs = 300;
      if (isMountain) avs = 450;
      else if (isPlateau) avs = 310;
      else if (isAlluvial) avs = 220;
      else if (isLowland) avs = 200;
      else if (nearCoast) avs = 180;

      // 都市域や埋立地の増幅（人工盛土の可能性）
      if (isUrban) avs = Math.min(avs + 20, 350);
      // 緯度による微調整（北より南で堆積傾向）
      avs += (35.5 - lat) * 2;

      // clamp
      avs = Math.max(80, Math.min(600, Math.round(avs)));

      // クラス判定
      const cls = findGeologyClassByAvs(avs);
      return { avs30: avs, type: cls.name, classKey: cls.key };
    }

    // 周波数依存簡易増幅率モデル（代表周波数 0.5Hz, 1.0Hz, 2.0Hz の重み付け平均）
    function calculateAmplificationFromAVS30(avs30Value) {
      // 周波数別の期待的増幅係数近似（簡易）
      // 低周波(0.5Hz): 低AVSで増幅が少ない
      // 中周波(1Hz): 典型的な建物共振域で増幅が最大になることがある
      // 高周波(2Hz): 表層の柔らかさで増幅が出やすい
      const f = [
        { freq:0.5, weight:0.3, a: Math.pow(400/avs30Value, 0.35) },
        { freq:1.0, weight:0.5, a: Math.pow(400/avs30Value, 0.7) },
        { freq:2.0, weight:0.2, a: Math.pow(400/avs30Value, 0.9) }
      ];
      let amp = 0;
      let wSum = 0;
      f.forEach(fn => { amp += fn.a * fn.weight; wSum += fn.weight; });
      amp = amp / wSum;
      // 範囲制限
      amp = Math.min(Math.max(amp, 0.7), 4.0);
      return amp;
    }

    // 距離・時間計算の改良：層別速度（表層 Vs, 上部地殻 Vc）を導入
    function toRad(deg){return deg*Math.PI/180;}
    function calculateDistance(lat1, lon1, lat2, lon2){
      const latAvg = (lat1+lat2)/2;
      const a=6378137, b=6356752.314245;
      const e2=(a*a-b*b)/(a*a);
      const W=Math.sqrt(1-e2*Math.sin(toRad(latAvg))**2);
      const M=(a*(1-e2))/(W**3);
      const N=a/W;
      const dLat=toRad(lat2-lat1);
      const dLon=toRad(lon2-lon1);
      const distance=Math.sqrt((M*dLat)**2 + (N*Math.cos(toRad(latAvg))*dLon)**2);
      return distance/1000;
    }
    function calculateHypocentralDistance(surfaceDistance, depth){ return Math.sqrt(surfaceDistance**2 + depth**2); }

    // 到達時間：表層経路（短い）と上部地殻経路を分けて近似
    function calculateSWaveArrivalTime(distanceKm, depthKm, avs30) {
      // 表層速度（m/s）を avs30 に依存
      const surfaceVs = Math.max(avs30, 120); // m/s 保護
      // 表層厚の想定（km）
      const surfaceThicknessKm = 0.03;
      // 上部地殻速度（km/s）—典型値 3.5 km/s を使用。ただし地盤が固い領域は若干速く。
      const crustVs = (avs30 > 360) ? 4.0 : 3.5; // km/s
      // 時間計算（秒）
      const hypoDistKm = calculateHypocentralDistance(distanceKm, depthKm);
      // 表層通過時間
      const surfaceTime = (surfaceThicknessKm) / (surfaceVs / 1000); // s (surfaceVs は m/s)
      // 残りを上部地殻速度で
      const crustTime = Math.max(0, (hypoDistKm - surfaceThicknessKm) / crustVs);
      return surfaceTime + crustTime;
    }

    // PGV 予測：安定化と最小限の保護を追加
    function predictPGV(M, X, depth) {
      const Mw = M;
      const D = Math.max(X, 0.5); // 0.5 km 以下の距離は安定化
      const depthFactor = 0.0038 * depth;
      const term = D + 0.0028 * Math.pow(10, 0.5 * Mw);
      const safeTerm = Math.max(term, 1e-6);
      const logPGV = 0.58 * Mw + depthFactor - 1.29 - Math.log10(safeTerm) - 0.002 * D;
      return Math.pow(10, logPGV);
    }

    function pgvToIntensity(pgv, amplification) {
      const adjustedPGV = Math.max(pgv * amplification, 1e-6);
      const I = 2.68 + 1.72 * Math.log10(adjustedPGV);
      return Math.max(0, I);
    }

    // UI コンポーネント（Preact + htm）
    function App(){
      const [magnitude, setMagnitude] = useState(7.0);
      const [depth, setDepth] = useState(10);
      const [epicenterLat, setEpicenterLat] = useState(35.6895);
      const [epicenterLon, setEpicenterLon] = useState(139.6917);
      const [targetLat, setTargetLat] = useState(35.7);
      const [targetLon, setTargetLon] = useState(139.7);
      const [autoAmplification, setAutoAmplification] = useState(true);
      const [avs30Val, setAvs30Val] = useState(300);
      const [geoType, setGeoType] = useState('計算中...');
      const [ampFactor, setAmpFactor] = useState(1.6);
      const [predicted, setPredicted] = useState(null);
      const [prefIntensities, setPrefIntensities] = useState({});
      const [japanData, setJapanData] = useState(null);
      const [simTime, setSimTime] = useState(0);
      const [simSpeed, setSimSpeed] = useState(1);
      const [isSimulating, setIsSimulating] = useState(false);
      const svgRef = useRef(null);
      const animRef = useRef(null);

      // GeoJSON ロード（フォールバック）
      useEffect(()=>{
        let mounted = true;
        (async ()=>{
          const sources = [
            'https://raw.githubusercontent.com/niiyz/JapanCityGeoJson/master/geojson/prefectures.json',
            'https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson'
          ];
          let data = null;
          for (const s of sources) {
            try {
              const r = await fetch(s);
              if (r.ok) { data = await r.json(); break; }
            } catch(e) { console.warn('geo load failed', s); }
          }
          if (!data) {
            data = { type: 'FeatureCollection', features: prefectures.map(pref => {
              const pts=[]; const radius=0.45;
              for (let i=0;i<=360;i+=10){
                const rad=i*Math.PI/180;
                const lat=pref.lat + radius*Math.sin(rad);
                const lon=pref.lon + radius*Math.cos(rad);
                pts.push([lon,lat]);
              }
              return { type:'Feature', properties:{name:pref.name}, geometry:{type:'Polygon', coordinates:[pts]} };
            })};
          }
          if (mounted) setJapanData(data);
        })();
        return ()=>{ mounted=false; }
      }, []);

      // AVS30 と増幅率計算
      useEffect(()=>{
        if (!autoAmplification) return;
        const d = estimateAVS30FromLocation(targetLat, targetLon);
        setAvs30Val(d.avs30);
        setGeoType(d.type);
        setAmpFactor(calculateAmplificationFromAVS30(d.avs30));
      }, [targetLat, targetLon, autoAmplification]);

      // 点予測
      useEffect(()=>{
        const surfDist = calculateDistance(epicenterLat, epicenterLon, targetLat, targetLon);
        const hypo = calculateHypocentralDistance(surfDist, depth);
        const pgv = predictPGV(magnitude, hypo, depth);
        const intensity = pgvToIntensity(pgv, ampFactor);
        setPredicted({ value:intensity, scale:getIntensityScale(intensity), pgv, surfaceDistance:surfDist, hypoDistance:hypo });
      }, [magnitude, depth, epicenterLat, epicenterLon, targetLat, targetLon, ampFactor]);

      // SVG 描画
      useEffect(()=>{
        if (!japanData) return;
        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();
        const width=900, height=720;
        svg.attr('viewBox','0 0 '+width+' '+height);
        svg.append('rect').attr('width',width).attr('height',height).attr('fill','#e8f4f8');
        const projection = d3.geoMercator().center([137,38]).scale(1450).translate([width/2,height/2]);
        const path = d3.geoPath().projection(projection);
        const g = svg.append('g');

        g.selectAll('path').data(japanData.features).enter().append('path')
          .attr('d', path)
          .attr('fill', d => {
            const prefName = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
            const intensity = prefIntensities[prefName];
            return intensity ? getIntensityColor(intensity.scale) : '#f7fafc';
          })
          .attr('stroke','#333').attr('stroke-width',0.4)
          .attr('opacity', d => {
            const prefName = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
            return prefIntensities[prefName] ? 0.95 : 0.65;
          });

        // 県庁所在地マーカー（小さく）
        prefectures.forEach(pref => {
          const intensity = prefIntensities[pref.name];
          const coords = projection([pref.lon, pref.lat]);
          // 常に小さい円を描画（色は到達時のみ強調）
          g.append('circle')
            .attr('cx', coords[0])
            .attr('cy', coords[1])
            .attr('r', intensity ? 4 : 2.5)
            .attr('fill', intensity ? getIntensityColor(intensity.scale) : '#666')
            .attr('stroke', intensity ? '#fff' : '#fff')
            .attr('stroke-width', 0.8);

          if (intensity) {
            g.append('text')
              .attr('x', coords[0])
              .attr('y', coords[1] - 8)
              .attr('text-anchor','middle')
              .attr('font-weight','600')
              .attr('font-size','11px')
              .attr('fill', getIntensityColor(intensity.scale))
              .text(intensity.scale);
          }
        });

        // 震源マーカー（小さく）
        const epicCoords = projection([epicenterLon, epicenterLat]);
        g.append('circle')
          .attr('cx', epicCoords[0])
          .attr('cy', epicCoords[1])
          .attr('r', 6)
          .attr('fill', '#ff3333')
          .attr('stroke', '#fff')
          .attr('stroke-width', 1.6);

        g.append('text')
          .attr('x', epicCoords[0])
          .attr('y', epicCoords[1] - 12)
          .attr('text-anchor','middle')
          .attr('font-weight','700')
          .attr('font-size','12px')
          .attr('fill','#ff3333')
          .text('震源');
      }, [japanData, prefIntensities, epicenterLat, epicenterLon]);

      // 全県計算（シミュレーション時）
      function calcAllPrefIntensities(currentTimeSec) {
        const out = {};
        prefectures.forEach(pref => {
          const d = calculateDistance(epicenterLat, epicenterLon, pref.lat, pref.lon);
          const prefGeo = estimateAVS30FromLocation(pref.lat, pref.lon);
          const arrival = calculateSWaveArrivalTime(d, depth, prefGeo.avs30);
          if (currentTimeSec >= arrival) {
            const hypo = calculateHypocentralDistance(d, depth);
            const amp = calculateAmplificationFromAVS30(prefGeo.avs30);
            const pgv = predictPGV(magnitude, hypo, depth);
            const intensity = pgvToIntensity(pgv, amp);
            out[pref.name] = { value:intensity, scale:getIntensityScale(intensity), arrivalTime:arrival, distance:d, avs30:prefGeo.avs30, geo:prefGeo.type };
          }
        });
        return out;
      }

      // シミュレーションループ
      function startSim(){
        if (isSimulating) return;
        setIsSimulating(true);
        const t0 = performance.now();
        function loop(){
          const elapsed = (performance.now() - t0)/1000;
          const t = elapsed * simSpeed;
          setSimTime(t);
          const ints = calcAllPrefIntensities(t);
          setPrefIntensities(ints);
          // 停止条件（最大距離の到達＋余裕）
          const maxD = Math.max(...prefectures.map(p=>calculateDistance(epicenterLat, epicenterLon, p.lat, p.lon)));
          const maxT = calculateSWaveArrivalTime(maxD, depth, 500);
          if (t < maxT + 8) { animRef.current = requestAnimationFrame(loop); }
          else { setIsSimulating(false); }
        }
        animRef.current = requestAnimationFrame(loop);
      }
      function stopSim(){ setIsSimulating(false); if (animRef.current) cancelAnimationFrame(animRef.current); }
      function resetSim(){ stopSim(); setSimTime(0); setPrefIntensities({}); }

      // UI 用補助：地点予測表示
      function pointPrediction() {
        const d = calculateDistance(epicenterLat, epicenterLon, targetLat, targetLon);
        const hypo = calculateHypocentralDistance(d, depth);
        const pgv = predictPGV(magnitude, hypo, depth);
        const amp = ampFactor;
        const intensity = pgvToIntensity(pgv, amp);
        return { value:intensity, scale:getIntensityScale(intensity), pgv, surfaceDistance:d };
      }

      // 初期 AVS30 計算
      useEffect(()=> {
        if (autoAmplification) {
          const d = estimateAVS30FromLocation(targetLat, targetLon);
          setAvs30Val(d.avs30); setGeoType(d.type); setAmpFactor(calculateAmplificationFromAVS30(d.avs30));
        }
      }, []);

      // JSX で UI を返す
      return html`
      <div class="min-h-screen">
        <div class="max-w-7xl mx-auto">
          <div class="bg-white rounded-lg shadow-xl p-6 mb-6">
            <div class="flex items-center gap-3 mb-4">
              <span>${Icon('activity',{width:32})}</span>
              <h1 class="text-3xl font-bold text-gray-800">高精度地震震度予測システム（改良版）</h1>
            </div>
            <p class="text-gray-600 mb-4">マーカーを小型化し、地層を細分化、到達時間と増幅モデルを改良しました</p>
          </div>

          <div class="grid lg:grid-cols-3 gap-6 mb-6">
            <div class="bg-white rounded-lg shadow-lg p-6">
              <div class="flex items-center gap-2 mb-4">
                <span>${Icon('map-pin')}</span>
                <h2 class="text-xl font-bold text-gray-800">震源と観測点</h2>
              </div>

              <div class="space-y-3">
                <div>
                  <label class="block text-sm text-gray-700">マグニチュード: <strong>${magnitude.toFixed(1)}</strong></label>
                  <input type="range" min="4.0" max="9.0" step="0.1" value=${magnitude} onInput=${e=>setMagnitude(parseFloat(e.target.value))} class="w-full"/>
                </div>

                <div>
                  <label class="block text-sm text-gray-700">震源深さ (km): <strong>${depth}</strong></label>
                  <input type="range" min="0" max="100" step="1" value=${depth} onInput=${e=>setDepth(parseInt(e.target.value))} class="w-full"/>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="block text-sm text-gray-700">観測点 緯度</label>
                    <input type="number" step="0.01" value=${targetLat} onInput=${e=>{ setTargetLat(parseFloat(e.target.value)); if (autoAmplification){ const d=estimateAVS30FromLocation(parseFloat(e.target.value), targetLon); setAvs30Val(d.avs30); setGeoType(d.type); setAmpFactor(calculateAmplificationFromAVS30(d.avs30)); }}} class="w-full px-2 py-1 border rounded text-sm"/>
                  </div>
                  <div>
                    <label class="block text-sm text-gray-700">観測点 経度</label>
                    <input type="number" step="0.01" value=${targetLon} onInput=${e=>{ setTargetLon(parseFloat(e.target.value)); if (autoAmplification){ const d=estimateAVS30FromLocation(targetLat, parseFloat(e.target.value)); setAvs30Val(d.avs30); setGeoType(d.type); setAmpFactor(calculateAmplificationFromAVS30(d.avs30)); }}} class="w-full px-2 py-1 border rounded text-sm"/>
                  </div>
                </div>

                <div>
                  <label class="block text-sm text-gray-700">震源 緯度</label>
                  <input type="number" step="0.01" value=${epicenterLat} onInput=${e=>setEpicenterLat(parseFloat(e.target.value))} class="w-full px-2 py-1 border rounded text-sm"/>
                </div>
                <div>
                  <label class="block text-sm text-gray-700">震源 経度</label>
                  <input type="number" step="0.01" value=${epicenterLon} onInput=${e=>setEpicenterLon(parseFloat(e.target.value))} class="w-full px-2 py-1 border rounded text-sm"/>
                </div>

                <div class="border-t pt-3">
                  <div class="flex items-center justify-between mb-2">
                    <label class="text-sm font-medium text-gray-700">地層データ自動計算</label>
                    <label class="relative inline-flex items-center cursor-pointer">
                      <input type="checkbox" checked=${autoAmplification} onChange=${e=>setAutoAmplification(e.target.checked)} class="sr-only"/>
                      <div class=${'switch ' + (autoAmplification ? 'on' : '')}><div class="knob"></div></div>
                    </label>
                  </div>

                  <div class="bg-green-50 p-3 rounded-md text-sm">
                    <p class="text-green-800 font-medium">地質: ${geoType}</p>
                    <p class="text-green-800">AVS30: ${avs30Val} m/s</p>
                    <p class="text-green-800">増幅率: ${ampFactor.toFixed(2)}</p>
                  </div>
                </div>

              </div>
            </div>

            <div class="bg-white rounded-lg shadow-lg p-6">
              <h2 class="text-xl font-bold mb-3">地点予測結果</h2>
              ${predicted ? html`
                <div style="background-color:${getIntensityColor(predicted.scale)}20" class="rounded-lg p-4 text-center mb-3">
                  <div class="text-5xl font-bold" style="color:${getIntensityColor(predicted.scale)}">${predicted.scale}</div>
                  <p class="text-sm text-gray-600 mt-1">計測震度: ${predicted.value.toFixed(2)}</p>
                </div>
                <div class="text-sm space-y-1">
                  <div class="flex justify-between"><span class="text-gray-600">震央距離:</span><span class="font-semibold">${predicted.surfaceDistance.toFixed(1)} km</span></div>
                  <div class="flex justify-between"><span class="text-gray-600">予測PGV:</span><span class="font-semibold">${predicted.pgv.toFixed(2)} cm/s</span></div>
                </div>
              ` : html`<div class="text-sm text-gray-600">計算中...</div>`}
            </div>

            <div class="bg-white rounded-lg shadow-lg p-6">
              <h2 class="text-xl font-bold mb-3">地層クラス（簡易割当）</h2>
              <div class="text-sm text-gray-700 space-y-1">
                ${geologyClasses.map(g => html`<div class="flex justify-between"><div>${g.key} — ${g.name}</div><div>${g.min}–${g.max} m/s (代表 ${g.rep})</div></div>`)}
              </div>
            </div>

          </div>

          <div class="bg-white rounded-lg shadow-xl p-6 mb-6">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-2xl font-bold text-gray-800">日本地図 震度分布シミュレーション</h2>
              <div class="flex gap-2 items-center">
                <select value=${simSpeed} onChange=${e=>setSimSpeed(parseFloat(e.target.value))} class="px-3 py-2 border rounded text-sm">
                  <option value="1">1倍速</option>
                  <option value="2">2倍速</option>
                  <option value="5">5倍速</option>
                  <option value="10">10倍速</option>
                </select>
                <button onClick=${startSim} class="px-4 py-2 bg-blue-600 text-white rounded">${Icon('play')} 開始</button>
                <button onClick=${stopSim} class="px-4 py-2 bg-yellow-600 text-white rounded">${Icon('pause')} 停止</button>
                <button onClick=${resetSim} class="px-4 py-2 bg-gray-600 text-white rounded">${Icon('rotate-ccw')} リセット</button>
              </div>
            </div>

            <div class="bg-gray-100 rounded-lg p-4 mb-4">
              <div class="flex justify-between">
                <span class="text-lg font-semibold">経過時間: ${simTime.toFixed(1)} 秒</span>
                <span class="text-sm text-gray-600">到達地域数: ${Object.keys(prefIntensities).length} / 47</span>
              </div>
            </div>

            <div class="relative bg-white rounded-lg p-4 border">
              <div style="min-height:460px;">
                <svg id="svgMap" ref=${svgRef}></svg>
              </div>
            </div>

            <div class="grid md:grid-cols-2 gap-4 mt-4">
              <div class="bg-gray-50 rounded-lg p-4">
                <h3 class="font-bold mb-2">到達済み地域（到達順）</h3>
                <div class="space-y-1 max-h-64 overflow-y-auto text-xs">
                  ${Object.entries(prefIntensities).sort((a,b)=>a[1].arrivalTime-b[1].arrivalTime).map(([name,data]) => html`
                    <div class="flex justify-between items-center p-2 bg-white rounded text-xs">
                      <div>
                        <div class="font-medium">${name}</div>
                        <div class="small-label text-gray-500">${data.geo} · AVS30:${data.avs30} m/s</div>
                      </div>
                      <div class="text-right">
                        <div class="text-gray-600">${data.arrivalTime.toFixed(1)} s</div>
                        <div style="background:${getIntensityColor(data.scale)}30;color:${getIntensityColor(data.scale)}" class="font-bold px-2 py-1 rounded">震度 ${data.scale}</div>
                      </div>
                    </div>
                  `)}
                </div>
              </div>

              <div class="bg-gray-50 rounded-lg p-4">
                <h3 class="font-bold mb-2">震度凡例</h3>
                <div class="grid grid-cols-2 gap-2">
                  ${['0','1','2','3','4','5弱','5強','6弱','6強','7'].map(scale => html`
                    <div class="flex items-center gap-2 p-2 bg-white rounded text-sm">
                      <div style="width:24px;height:24px;background:${getIntensityColor(scale)};border-radius:4px"></div>
                      <span>震度 ${scale}</span>
                    </div>`)}
                </div>
              </div>
            </div>

          </div>

          <div class="bg-white rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-bold mb-3">データソースと改良点</h3>
            <div class="text-sm text-gray-600">
              <ul class="list-disc list-inside">
                <li>GeoJSON（ブラウザフェッチ、フォールバックあり）</li>
                <li>地層クラスを 9 段階に細分化し、AVS30 をより精密に推定</li>
                <li>増幅率は周波数依存の簡易モデルを採用</li>
                <li>到達時間は表層厚と上部地殻速度を分離して近似</li>
                <li>PGV モデルに数値安定化処理を追加</li>
              </ul>
            </div>
          </div>

        </div>
      </div>
      `;
    }

    render(h(App, {}), document.getElementById('app'));
  })();
  </script>
</body>
</html>

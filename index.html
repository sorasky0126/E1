<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>震度予測 — AVS30 タイル + 1D サイト応答（デモ）</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .switch{width:44px;height:24px;background:#d1d5db;border-radius:999px;position:relative;display:inline-block;}
  .switch>.knob{width:20px;height:20px;background:#fff;border-radius:999px;position:absolute;left:2px;top:2px;transition:all .2s}
  .switch.on{background:#2563eb}.switch.on>.knob{transform:translateX(20px)}
  svg#mapSvg{width:100%;height:auto;max-height:780px;display:block}
  .small-label{font-size:11px}
  .legend-swatch{width:22px;height:22px;border-radius:4px;display:inline-block;margin-right:8px}
</style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
<div class="max-w-7xl mx-auto">
  <div class="bg-white p-6 rounded-lg shadow mb-6">
    <h1 class="text-2xl font-bold">震度予測（AVS30 タイル + 1D サイト応答）</h1>
    <p class="text-sm text-gray-600 mt-1">デモ実装。実運用では AVS30 データを R2 等に置いて tileUrlBase を差し替えてください。</p>
  </div>

  <div class="grid lg:grid-cols-3 gap-6 mb-6">
    <div class="bg-white p-6 rounded shadow">
      <h2 class="font-bold mb-3">震源 / 観測点</h2>
      <label class="block text-sm">M: <span id="magLabel">7.0</span></label>
      <input id="mag" type="range" min="4" max="9" step="0.1" value="7" class="w-full mb-3"/>
      <label class="block text-sm">depth km: <span id="depthLabel">10</span></label>
      <input id="depth" type="range" min="0" max="100" step="1" value="10" class="w-full mb-3"/>
      <div class="grid grid-cols-2 gap-2 mb-2">
        <div><label class="text-sm">観測 緯度</label><input id="tlat" type="number" step="0.01" value="35.7" class="border rounded w-full px-2 py-1"></div>
        <div><label class="text-sm">観測 経度</label><input id="tlon" type="number" step="0.01" value="139.7" class="border rounded w-full px-2 py-1"></div>
      </div>
      <div class="grid grid-cols-2 gap-2 mb-2">
        <div><label class="text-sm">震源 緯度</label><input id="elat" type="number" step="0.01" value="35.6895" class="border rounded w-full px-2 py-1"></div>
        <div><label class="text-sm">震源 経度</label><input id="elon" type="number" step="0.01" value="139.6917" class="border rounded w-full px-2 py-1"></div>
      </div>

      <div class="mt-2">
        <div class="flex items-center justify-between">
          <div>AVS30 自動取得</div>
          <div id="autoSwitch" class="switch on"><div class="knob"></div></div>
        </div>
        <div class="bg-green-50 p-2 rounded mt-2 text-sm">
          <div>地質: <span id="geoType">計算中...</span></div>
          <div>AVS30: <span id="avsVal">300</span> m/s</div>
          <div>サイト増幅 (weighted): <span id="siteAmp">1.6</span></div>
        </div>
      </div>
    </div>

    <div class="bg-white p-6 rounded shadow">
      <h2 class="font-bold mb-3">地点予測</h2>
      <div id="predCard" class="rounded p-4 text-center" style="background:#f3f4f6">
        <div id="predScale" class="text-4xl font-bold">--</div>
        <div id="predVal" class="text-sm text-gray-600">計算待ち</div>
      </div>
      <div class="mt-3 text-sm">
        <div class="flex justify-between"><span>震央距離</span><span id="distVal">-- km</span></div>
        <div class="flex justify-between"><span>予測 PGV</span><span id="pgvVal">-- cm/s</span></div>
      </div>
    </div>

    <div class="bg-white p-6 rounded shadow">
      <h2 class="font-bold mb-3">設定 / データソース</h2>
      <div class="text-sm mb-2">AVS30 タイルベース (XYZ PNG/WEBP)。実運用では R2 の URL に置き換えてください。</div>
      <div class="text-xs text-gray-600 mb-2">tileUrlBase example: https://your-cf-worker.example.com/avs30/{z}/{x}/{y}.png</div>
      <label class="text-sm">Tile URL base</label>
      <input id="tileUrlBase" class="border rounded w-full px-2 py-1 text-sm mb-2"
             value="https://example.com/tiles/avs30/{z}/{x}/{y}.png"/>
      <div class="text-xs text-gray-600">注意: データは AVS30 (m/s) をピクセル値化した PNG を想定（例えばグレースケール値→AVS30）。</div>
    </div>
  </div>

  <div class="bg-white p-4 rounded shadow mb-6">
    <div class="flex justify-between items-center mb-2">
      <h2 class="font-bold">日本地図（TopoJSON）</h2>
      <div>
        <button id="startBtn" class="px-3 py-1 bg-blue-600 text-white rounded mr-2">開始</button>
        <button id="stopBtn" class="px-3 py-1 bg-yellow-500 text-white rounded hidden">停止</button>
        <button id="resetBtn" class="px-3 py-1 bg-gray-600 text-white rounded">リセット</button>
      </div>
    </div>

    <div class="flex gap-4 mb-3">
      <div>経過: <span id="simT">0.0</span>s</div>
      <div>到達: <span id="reachedCount">0</span>/47</div>
    </div>

    <div class="border rounded p-2 bg-gray-50">
      <svg id="mapSvg" viewBox="0 0 900 720"></svg>
    </div>

    <div class="grid md:grid-cols-2 gap-4 mt-3">
      <div class="bg-gray-50 p-3 rounded">
        <h3 class="font-bold text-sm mb-2">到達済み地域（順）</h3>
        <div id="reachList" style="max-height:240px;overflow:auto"></div>
      </div>
      <div class="bg-gray-50 p-3 rounded">
        <h3 class="font-bold text-sm mb-2">凡例</h3>
        <div id="legend" class="text-sm"></div>
      </div>
    </div>
  </div>

  <div class="bg-white p-4 rounded shadow text-sm">
    <h3 class="font-bold">注記</h3>
    <ul class="list-disc list-inside">
      <li>AVS30 の実データを R2 に置き、tileUrlBase を実URLに差し替えてください。</li>
      <li>1D サイト応答は簡易モデルです。より正確には J-SHIS 等の分布・1D/2Dサイト解析を利用してください。</li>
    </ul>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<script>
/* -----------------------
   ユーティリティ / 物理モデル
   ----------------------- */

// 都道府県座標（県庁所在地）
const prefectures = [
  { code:1,name:'北海道',lat:43.0642,lon:141.3469},{code:2,name:'青森県',lat:40.8244,lon:140.7400},
  {code:3,name:'岩手県',lat:39.7036,lon:141.1527},{code:4,name:'宮城県',lat:38.2682,lon:140.8694},
  {code:5,name:'秋田県',lat:39.7186,lon:140.1024},{code:6,name:'山形県',lat:38.2404,lon:140.3633},
  {code:7,name:'福島県',lat:37.7503,lon:140.4676},{code:8,name:'茨城県',lat:36.3418,lon:140.4468},
  {code:9,name:'栃木県',lat:36.5658,lon:139.8836},{code:10,name:'群馬県',lat:36.3911,lon:139.0608},
  {code:11,name:'埼玉県',lat:35.8617,lon:139.6455},{code:12,name:'千葉県',lat:35.6074,lon:140.1065},
  {code:13,name:'東京都',lat:35.6895,lon:139.6917},{code:14,name:'神奈川県',lat:35.4437,lon:139.6380},
  {code:15,name:'新潟県',lat:37.9026,lon:139.0232},{code:16,name:'富山県',lat:36.6953,lon:137.2113},
  {code:17,name:'石川県',lat:36.5946,lon:136.6256},{code:18,name:'福井県',lat:36.0652,lon:136.2216},
  {code:19,name:'山梨県',lat:35.6642,lon:138.5684},{code:20,name:'長野県',lat:36.6513,lon:138.1810},
  {code:21,name:'岐阜県',lat:35.3912,lon:136.7223},{code:22,name:'静岡県',lat:34.9769,lon:138.3831},
  {code:23,name:'愛知県',lat:35.1815,lon:136.9066},{code:24,name:'三重県',lat:34.7303,lon:136.5086},
  {code:25,name:'滋賀県',lat:35.0045,lon:135.8686},{code:26,name:'京都府',lat:35.0116,lon:135.7681},
  {code:27,name:'大阪府',lat:34.6937,lon:135.5023},{code:28,name:'兵庫県',lat:34.6901,lon:135.1955},
  {code:29,name:'奈良県',lat:34.6851,lon:135.8329},{code:30,name:'和歌山県',lat:34.2261,lon:135.1675},
  {code:31,name:'鳥取県',lat:35.5014,lon:134.2382},{code:32,name:'島根県',lat:35.4723,lon:133.0505},
  {code:33,name:'岡山県',lat:34.6617,lon:133.9350},{code:34,name:'広島県',lat:34.3965,lon:132.4596},
  {code:35,name:'山口県',lat:34.1861,lon:131.4706},{code:36,name:'徳島県',lat:34.0658,lon:134.5594},
  {code:37,name:'香川県',lat:34.3401,lon:134.0434},{code:38,name:'愛媛県',lat:33.8416,lon:132.7657},
  {code:39,name:'高知県',lat:33.5597,lon:133.5311},{code:40,name:'福岡県',lat:33.6064,lon:130.4181},
  {code:41,name:'佐賀県',lat:33.2494,lon:130.2988},{code:42,name:'長崎県',lat:32.7503,lon:129.8777},
  {code:43,name:'熊本県',lat:32.7898,lon:130.7417},{code:44,name:'大分県',lat:33.2382,lon:131.6126},
  {code:45,name:'宮崎県',lat:31.9077,lon:131.4202},{code:46,name:'鹿児島県',lat:31.5602,lon:130.5581},
  {code:47,name:'沖縄県',lat:26.2124,lon:127.6809}
];

// 基本関数
function toRad(deg){return deg*Math.PI/180;}
function calculateDistance(lat1,lon1,lat2,lon2){
  const latAvg=(lat1+lat2)/2; const a=6378137,b=6356752.314245; const e2=(a*a-b*b)/(a*a);
  const W=Math.sqrt(1-e2*Math.sin(toRad(latAvg))**2); const M=(a*(1-e2))/(W**3); const N=a/W;
  const dLat=toRad(lat2-lat1); const dLon=toRad(lon2-lon1);
  const distance=Math.sqrt((M*dLat)**2 + (N*Math.cos(toRad(latAvg))*dLon)**2);
  return distance/1000;
}
function calculateHypocentralDistance(surfaceDistance, depth){ return Math.sqrt(surfaceDistance**2 + depth**2); }

// 簡易 AVS30 推定（より詳細を取り込みたい場合は外部タイルを利用）
function estimateAVS30FromLocation(lat,lon){
  // 基本: 沿岸低地を低く、山地を高く、都市をやや高めに
  let avs = 300;
  if (lat>38 || lon<132) avs = 450; // 山地的
  else if (lat<34 && lon>130 && lon<133) avs = 200; // 南部沿岸
  else if (lat>35 && lat<37 && lon>138 && lon<140) avs = 220; // 関東平野系
  // 都市補正（簡易）
  const urbanCenters=[{lat:35.68,lon:139.76,r:50},{lat:34.69,lon:135.50,r:40},{lat:35.18,lon:136.91,r:30}];
  for(const c of urbanCenters){ if (calculateDistance(lat,lon,c.lat,c.lon)<=c.r) avs=Math.min(avs+30,380); }
  return Math.round(avs);
}

// ---- AVS30 タイル読み出しユーティリティ（PNG グレースケールから AVS30 を復元する仮定） ----
// 実運用: tileUrlBase を R2 の公開URLにし、PNG にエンコードした AVS30 値(例: R=round(AVS30/2) 等) を保存しておく。
// ここではモック：ネットワークがない場合は estimateAVS30FromLocation を落とし込み。
async function fetchAvsFromTile(tileUrlBase, lat, lon, z=8) {
  // tileUrlBase: "https://.../avs30/{z}/{x}/{y}.png" を想定
  if (!tileUrlBase || tileUrlBase.indexOf('{z}')===-1) return estimateAVS30FromLocation(lat,lon);

  // convert lat/lon to tile x/y
  const xyz = latLonToTile(lat, lon, z);
  const url = tileUrlBase.replace('{z}', z).replace('{x}', xyz.x).replace('{y}', xyz.y);
  try {
    const resp = await fetch(url);
    if (!resp.ok) return estimateAVS30FromLocation(lat,lon);
    const blob = await resp.blob();
    // 読み込み PNG->キャンバス->ピクセル -> グレースケール値を取得
    const avs = await pngBlobToAvs(blob, lat, lon, z, xyz.x, xyz.y);
    return avs;
  } catch(e){
    console.warn('tile fetch failed', e);
    return estimateAVS30FromLocation(lat,lon);
  }
}
function latLonToTile(lat, lon, z){
  const xtile = Math.floor((lon + 180) / 360 * Math.pow(2, z));
  const ytile = Math.floor((1 - Math.log(Math.tan(toRad(lat)) + 1/Math.cos(toRad(lat))) / Math.PI) / 2 * Math.pow(2, z));
  return {x:xtile,y:ytile};
}
function pngBlobToAvs(blob, lat, lon, z, x, y){
  // 実運用では、タイルに格納した AVS30 のエンコード方法に従って復元する。
  // ここでは簡易: タイル中央ピクセルの R 値を AVS30 の線形スケール(0-255 -> 0-600 m/s)で復元する例。
  return new Promise((resolve)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = function(){
      const c = document.createElement('canvas');
      c.width = img.width; c.height = img.height;
      const ctx=c.getContext('2d'); ctx.drawImage(img,0,0);
      const cx = Math.floor(img.width/2), cy = Math.floor(img.height/2);
      const p = ctx.getImageData(cx,cy,1,1).data; // RGBA
      URL.revokeObjectURL(url);
      const gray = (p[0]*0.299 + p[1]*0.587 + p[2]*0.114);
      // scale: 0->50 m/s, 255->550 m/s （例）
      const avs = Math.round(50 + (gray/255)*(500));
      resolve(avs);
    };
    img.onerror = function(){ URL.revokeObjectURL(url); resolve(estimateAVS30FromLocation(lat,lon)); };
    img.src = url;
  });
}

// ---- 1Dサイト応答（簡易周波数領域モデル） ----
// 単層近似: 表層厚 H (m), Vs (m/s), 密度 rho (kg/m3). 下部は半空間 with Vs_sub
// 周波数 f の伝達関数 T(f) を計算: T = 1 / |cos(kH) - i*(rho*Vs/(rho_sub*Vs_sub))*sin(kH)| のような簡易式を用いる。
// ここでは非常に単純化した伝達関数で、ピーク周波数 f0 = Vs / (4H) を用いてバンドパス状の増幅を与える。
function compute1DSiteAmplification(avs30, options){
  // options: 層厚 H(m) を仮定。代表値: 軟弱地盤は H=30m, 堅い地盤は H=5m
  let H = 20;
  if (avs30 < 140) H = 40;
  else if (avs30 < 200) H = 30;
  else if (avs30 < 300) H = 20;
  else if (avs30 < 380) H = 12;
  else H = 6;

  // 層速度 Vs ≒ avs30 (近似) ; 下部 Vs_sub = 800 m/s
  const Vs = avs30;
  const Vs_sub = 800;
  const rho = 1800, rho_sub = 2700;

  // 周波数配列
  const freqs = [];
  for (let f=0.25; f<=8; f+=0.25) freqs.push(f);

  // 単純 TF: 低周波でほぼ1, 共振周波数 f0 = Vs/(4H) 付近でピーク、ピーク幅は Q で制御
  const f0 = Vs / (4*H);
  const Q = 8 + (avs30/100); // 堅いほど Q 高め
  const amps = freqs.map(f=>{
    const denom = Math.sqrt((1 - (f/f0)**2)**2 + (f/(f0*Q))**2);
    // baseline 0.9-1.1 depending on avs30
    const baseline = Math.max(0.8, Math.min(1.15, 1.0 - (avs30-300)/1000));
    const gain = baseline * (1 + (1/denom - 1)*0.9); // 1D peak scaling
    return {f, gain};
  });

  // 代表増幅（PGV に効く周波数域 0.5-2Hz を重視した加重平均）
  const weights = freqs.map(f=>{
    if (f<0.5) return 0.2;
    if (f<1) return 0.4;
    if (f<2) return 0.3;
    return 0.1;
  });
  let weighted = 0, wsum=0;
  amps.forEach((a,i)=>{ weighted += a.gain * weights[i]; wsum += weights[i]; });
  const representativeAmp = weighted / wsum;
  return {freqs, amps, representativeAmp, H, f0, Q};
}

// ---- PGV モデル（元コードベース） ----
function predictPGV(M, X, depth) {
  const Mw=M;
  const D=Math.max(X,0.5);
  const depthFactor = 0.0038*depth;
  const term = D + 0.0028*Math.pow(10,0.5*Mw);
  const logPGV = 0.58*Mw + depthFactor - 1.29 - Math.log10(Math.max(term,1e-6)) - 0.002*D;
  return Math.pow(10,logPGV); // cm/s
}
function pgvToIntensity(pgv){
  const I = 2.68 + 1.72*Math.log10(Math.max(pgv,1e-6));
  return Math.max(0,I);
}
function getIntensityScale(I){
  if (I<0.5) return '0';
  if (I<1.5) return '1';
  if (I<2.5) return '2';
  if (I<3.5) return '3';
  if (I<4.5) return '4';
  if (I<5.0) return '5弱';
  if (I<5.5) return '5強';
  if (I<6.0) return '6弱';
  if (I<6.5) return '6強';
  return '7';
}
function getIntensityColor(scale){
  const colors={'0':'#C0C0C0','1':'#3B82F6','2':'#10B981','3':'#FBBF24','4':'#F97316','5弱':'#EF4444','5強':'#DC2626','6弱':'#B91C1C','6強':'#991B1B','7':'#7C3AED'};
  return colors[scale]||'#C0C0C0';
}

/* -----------------------
   UI / 地図描画 / シミュレーション
   ----------------------- */

const svg = d3.select('#mapSvg');
const width=900,height=720;
svg.attr('viewBox',`0 0 ${width} ${height}`);
svg.append('rect').attr('width',width).attr('height',height).attr('fill','#e8f4f8');

let japanTopo = null; // topojson / geojson
let prefInt = {}; // 到達県データ

// topojsonを読み込む：ここでは GitHub の prefectures topojson を読み込む想定。
// 必要であれば prefectures.geojson（FeatureCollection）でもOK。
// サンプル: https://raw.githubusercontent.com/niiyz/JapanCityGeoJson/master/geojson/prefectures.json
async function loadTopoJson(){
  try {
    const res = await fetch('https://raw.githubusercontent.com/niiyz/JapanCityGeoJson/master/geojson/prefectures.json');
    if (!res.ok) throw new Error('fail');
    japanTopo = await res.json();
    renderBaseMap();
  } catch(e){
    // フォールバックで簡易円形ポリゴンを生成
    const features = prefectures.map(p=>{
      const pts=[]; const r=0.45;
      for(let i=0;i<=360;i+=10){ const rad=i*Math.PI/180; pts.push([p.lon + r*Math.cos(rad), p.lat + r*Math.sin(rad)]) }
      return {type:'Feature', properties:{name:p.name}, geometry:{type:'Polygon', coordinates:[pts]}};
    });
    japanTopo = {type:'FeatureCollection', features};
    renderBaseMap();
  }
}

function renderBaseMap(){
  svg.selectAll('*').remove();
  svg.append('rect').attr('width',width).attr('height',height).attr('fill','#e8f4f8');

  const projection = d3.geoMercator().center([137,38]).scale(1450).translate([width/2,height/2]);
  const path = d3.geoPath().projection(projection);
  const g = svg.append('g');

  g.selectAll('path').data(japanTopo.features).enter().append('path')
    .attr('d', path)
    .attr('fill', d => {
      const name = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
      const it = prefInt[name];
      return it ? getIntensityColor(it.scale) : '#f7fafc';
    })
    .attr('stroke','#333').attr('stroke-width',0.4)
    .attr('opacity', d => (prefInt[d.properties.name]?0.95:0.65));

  // 県庁所在地マーカー（小）
  prefectures.forEach(p=>{
    const coords = projection([p.lon,p.lat]);
    const it = prefInt[p.name];
    g.append('circle').attr('cx',coords[0]).attr('cy',coords[1]).attr('r', it?4:2.5)
      .attr('fill', it?getIntensityColor(it.scale):'#666').attr('stroke','#fff').attr('stroke-width',0.8);
    if (it){
      g.append('text').attr('x',coords[0]).attr('y',coords[1]-8).attr('text-anchor','middle')
        .attr('font-size','11px').attr('font-weight','600').attr('fill',getIntensityColor(it.scale)).text(it.scale);
    }
  });

  // 震源マーカー
  const elan = parseFloat(document.getElementById('elon').value);
  const elat = parseFloat(document.getElementById('elat').value);
  const epic = projection([elan,elat]);
  g.append('circle').attr('cx',epic[0]).attr('cy',epic[1]).attr('r',6).attr('fill','#ff3333').attr('stroke','#fff').attr('stroke-width',1.2);
  g.append('text').attr('x',epic[0]).attr('y',epic[1]-12).attr('text-anchor','middle').attr('fill','#ff3333').attr('font-weight','700').text('震源');
}

loadTopoJson();

// UI bindings
const mag = document.getElementById('mag');
const depth = document.getElementById('depth');
const magLabel = document.getElementById('magLabel');
const depthLabel = document.getElementById('depthLabel');
const tlatIn = document.getElementById('tlat'), tlonIn = document.getElementById('tlon');
const elatIn = document.getElementById('elat'), elonIn = document.getElementById('elon');
const tileUrlBaseInput = document.getElementById('tileUrlBase');
const siteGeoLabel = document.getElementById('geoType'), avsValLabel = document.getElementById('avsVal'), siteAmpLabel = document.getElementById('siteAmp');
const predScale = document.getElementById('predScale'), predVal = document.getElementById('predVal'), distVal = document.getElementById('distVal'), pgvVal = document.getElementById('pgvVal');
const reachList = document.getElementById('reachList'), simT = document.getElementById('simT'), reachedCount = document.getElementById('reachedCount');
const legendDiv = document.getElementById('legend');

mag.oninput = ()=>{ magLabel.textContent = parseFloat(mag.value).toFixed(1); computePointPrediction(); };
depth.oninput = ()=>{ depthLabel.textContent = depth.value; computePointPrediction(); };
[tlatIn, tlonIn, elatIn, elonIn, tileUrlBaseInput].forEach(el => el.onchange = ()=>computePointPrediction());

document.getElementById('autoSwitch').onclick = function(){
  this.classList.toggle('on');
  computePointPrediction();
};

function updateLegend(){
  const scales = ['0','1','2','3','4','5弱','5強','6弱','6強','7'];
  legendDiv.innerHTML = scales.map(s=>`<div class="mb-1"><span class="legend-swatch" style="background:${getIntensityColor(s)}"></span> 震度 ${s}</div>`).join('');
}
updateLegend();

// Point prediction pipeline: fetch AVS30 (tile or estimate) -> compute 1D site response -> PGV * siteAmp -> intensity
async function computePointPrediction(){
  const mz = parseFloat(mag.value);
  const dp = parseFloat(depth.value);
  const tlat = parseFloat(tlatIn.value), tlon = parseFloat(tlonIn.value);
  // fetch avs30
  const base = tileUrlBaseInput.value.trim();
  const avs = await fetchAvsFromTile(base, tlat, tlon, 8); // zoom level 8 by default for example
  siteGeoLabel.textContent = avs>400?'基盤':'堆積';
  avsValLabel.textContent = avs;
  const site = compute1DSiteAmplification(avs);
  siteAmpLabel.textContent = site.representativeAmp.toFixed(2);
  // PGV
  const surfDist = calculateDistance(parseFloat(elatIn.value), parseFloat(elonIn.value), tlat, tlon);
  const hypo = calculateHypocentralDistance(surfDist, dp);
  const pgv = predictPGV(mz, hypo, dp);
  // Apply site amp
  const pgv_site = pgv * site.representativeAmp;
  const I = pgvToIntensity(pgv_site);
  predScale.textContent = getIntensityScale(I);
  predVal.textContent = '計測震度: ' + I.toFixed(2);
  distVal.textContent = surfDist.toFixed(1) + ' km';
  pgvVal.textContent = pgv_site.toFixed(2) + ' cm/s';
}

// Simulation loop (県ごと)
let simAnim = null;
let simStart = null;
let isRunning=false;
document.getElementById('startBtn').onclick = ()=>startSim();
document.getElementById('stopBtn').onclick = ()=>stopSim();
document.getElementById('resetBtn').onclick = ()=>resetSim();

async function calcPrefectureIntensities(simTime){
  const base = tileUrlBaseInput.value.trim();
  const dp = parseFloat(depth.value);
  const mz = parseFloat(mag.value);
  const out = {};
  for (const p of prefectures){
    // get avs from tiles (or estimate)
    const avs = await fetchAvsFromTile(base, p.lat, p.lon, 8);
    const arrive = calculateSWaveArrivalTimeEnhanced(p, dp, avs); // we'll use enhanced arrival below
    if (simTime >= arrive) {
      // compute PGV
      const d = calculateDistance(parseFloat(elatIn.value), parseFloat(elonIn.value), p.lat, p.lon);
      const hypo = calculateHypocentralDistance(d, dp);
      const pgv = predictPGV(mz, hypo, dp);
      const site = compute1DSiteAmplification(avs);
      const pgv_site = pgv * site.representativeAmp;
      const I = pgvToIntensity(pgv_site);
      out[p.name] = { value:I, scale:getIntensityScale(I), arrivalTime:arrive, distance:d, avs30:avs, geo:site.H?('H=' + site.H + 'm'):'-'};
    }
  }
  return out;
}

// Improved arrival time using layered speed: surface thickness + crust Vs
function calculateSWaveArrivalTimeEnhanced(pref, depthKm, avs30){
  const dist = calculateDistance(parseFloat(elatIn.value), parseFloat(elonIn.value), pref.lat, pref.lon);
  const surfaceThicknessKm = 0.03; // 30m
  const surfaceVs = Math.max(avs30, 120); // m/s
  const crustVs = (avs30>360)?4.0:3.5; // km/s
  const hypo = calculateHypocentralDistance(dist, depthKm);
  const surfaceTime = surfaceThicknessKm / (surfaceVs/1000);
  const crustTime = Math.max(0, (hypo - surfaceThicknessKm) / crustVs);
  return surfaceTime + crustTime;
}

async function simStep(){
  const now = (performance.now() - simStart)/1000;
  simT.textContent = now.toFixed(1);
  const ints = await calcPrefectureIntensities(now);
  prefInt = ints;
  reachedCount.textContent = Object.keys(ints).length;
  // render
  renderBaseMapWithData(prefInt);
  // list
  reachList.innerHTML = Object.entries(ints).sort((a,b)=>a[1].arrivalTime-b[1].arrivalTime).map(([name,d])=>
    `<div class="p-2 border-b"><div class="font-semibold">${name}</div><div class="text-xs text-gray-500">${d.arrivalTime.toFixed(1)} s · AVS30:${d.avs30}</div><div style="background:${getIntensityColor(d.scale)}30;color:${getIntensityColor(d.scale)}" class="inline-block px-2 py-1 rounded font-bold">震度 ${d.scale}</div></div>`
  ).join('');
  if (isRunning){
    // stopping criterion: when all 47 reached
    if (Object.keys(ints).length >= 47){ stopSim(); return; }
    simAnim = requestAnimationFrame(simStep);
  }
}

async function startSim(){
  if (isRunning) return;
  isRunning=true;
  simStart = performance.now();
  document.getElementById('startBtn').classList.add('hidden');
  document.getElementById('stopBtn').classList.remove('hidden');
  simAnim = requestAnimationFrame(simStep);
}
function stopSim(){
  isRunning=false;
  if (simAnim) cancelAnimationFrame(simAnim);
  document.getElementById('startBtn').classList.remove('hidden');
  document.getElementById('stopBtn').classList.add('hidden');
}
function resetSim(){
  stopSim();
  prefInt = {};
  simT.textContent = '0.0';
  reachedCount.textContent = '0';
  reachList.innerHTML = '';
  renderBaseMap();
}

// render with prefInt
function renderBaseMapWithData(prefIntData){
  svg.selectAll('*').remove();
  svg.append('rect').attr('width',width).attr('height',height).attr('fill','#e8f4f8');
  const projection = d3.geoMercator().center([137,38]).scale(1450).translate([width/2,height/2]);
  const path = d3.geoPath().projection(projection);
  const g = svg.append('g');
  g.selectAll('path').data(japanTopo.features).enter().append('path')
    .attr('d', path)
    .attr('fill', d=> { const nm=d.properties.name; const it=prefIntData[nm]; return it?getIntensityColor(it.scale):'#f7fafc'; })
    .attr('stroke','#333').attr('stroke-width',0.4).attr('opacity',d=>prefIntData[d.properties.name]?0.95:0.65);
  prefectures.forEach(p=>{
    const coords = projection([p.lon,p.lat]);
    const it = prefIntData[p.name];
    g.append('circle').attr('cx',coords[0]).attr('cy',coords[1]).attr('r',it?4:2.5)
      .attr('fill',it?getIntensityColor(it.scale):'#666').attr('stroke','#fff').attr('stroke-width',0.8);
    if (it){
      g.append('text').attr('x',coords[0]).attr('y',coords[1]-8).attr('text-anchor','middle').attr('font-size','11px').attr('font-weight','600').attr('fill',getIntensityColor(it.scale)).text(it.scale);
    }
  });
  // epicenter
  const epic = projection([parseFloat(elonIn.value),parseFloat(elatIn.value)]);
  g.append('circle').attr('cx',epic[0]).attr('cy',epic[1]).attr('r',6).attr('fill','#ff3333').attr('stroke','#fff').attr('stroke-width',1.2);
  g.append('text').attr('x',epic[0]).attr('y',epic[1]-12).attr('text-anchor','middle').attr('fill','#ff3333').attr('font-weight','700').text('震源');
}

// 初回 prediction
computePointPrediction();
renderBaseMap();

</script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>震度予測（深さ依存Vs実装版）</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  .switch { width: 44px; height: 24px; background: #d1d5db; border-radius: 999px; position: relative; display:inline-block; vertical-align: middle; }
  .switch > .knob { width:20px;height:20px;background:#fff;border-radius:999px;position:absolute;left:2px;top:2px;transition: all .2s;box-shadow:0 1px 3px rgba(0,0,0,.2); }
  .switch.on{background:#2563eb;}
  .switch.on > .knob{transform: translateX(20px);}
  .icon { vertical-align: -0.15em; }
  #svgMap { max-height: 760px; width: 100%; height: auto; display:block; }
  .small-label { font-size: 11px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; }
</style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
  <div id="app"></div>

  <!-- libs -->
  <script src="https://unpkg.com/preact@10.16.0/dist/preact.umd.js"></script>
  <script src="https://unpkg.com/preact@10.16.0/hooks/dist/hooks.umd.js"></script>
  <script src="https://unpkg.com/htm@3.1.1/dist/htm.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://unpkg.com/lucide@0.263.0/dist/lucide.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/geotiff/dist/geotiff.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.8.0/dist/proj4.js"></script>

  <script>
  (function(){
    const { h, render } = preact;
    const { useState, useEffect, useRef } = preactHooks;
    const html = htm.bind(h);

    function Icon(name, props = {}) {
      try {
        const svg = lucide.createIcon(name, Object.assign({width:24,height:24,class:'icon'}, props));
        const wrapper = document.createElement('span');
        wrapper.innerHTML = svg.toString();
        return h('span', { dangerouslySetInnerHTML: { __html: wrapper.innerHTML } });
      } catch(e) { return h('span', null); }
    }

    // prefecture list (省略せず前出と同じ)
    const prefectures = [
      { code: 1, name: '北海道', city: '札幌', lat: 43.0642, lon: 141.3469 },
      { code: 2, name: '青森県', city: '青森', lat: 40.8244, lon: 140.7400 },
      { code: 3, name: '岩手県', city: '盛岡', lat: 39.7036, lon: 141.1527 },
      { code: 4, name: '宮城県', city: '仙台', lat: 38.2682, lon: 140.8694 },
      { code: 5, name: '秋田県', city: '秋田', lat: 39.7186, lon: 140.1024 },
      { code: 6, name: '山形県', city: '山形', lat: 38.2404, lon: 140.3633 },
      { code: 7, name: '福島県', city: '福島', lat: 37.7503, lon: 140.4676 },
      { code: 8, name: '茨城県', city: '水戸', lat: 36.3418, lon: 140.4468 },
      { code: 9, name: '栃木県', city: '宇都宮', lat: 36.5658, lon: 139.8836 },
      { code: 10, name: '群馬県', city: '前橋', lat: 36.3911, lon: 139.0608 },
      { code: 11, name: '埼玉県', city: 'さいたま', lat: 35.8617, lon: 139.6455 },
      { code: 12, name: '千葉県', city: '千葉', lat: 35.6074, lon: 140.1065 },
      { code: 13, name: '東京都', city: '東京', lat: 35.6895, lon: 139.6917 },
      { code: 14, name: '神奈川県', city: '横浜', lat: 35.4437, lon: 139.6380 },
      { code: 15, name: '新潟県', city: '新潟', lat: 37.9026, lon: 139.0232 },
      { code: 16, name: '富山県', city: '富山', lat: 36.6953, lon: 137.2113 },
      { code: 17, name: '石川県', city: '金沢', lat: 36.5946, lon: 136.6256 },
      { code: 18, name: '福井県', city: '福井', lat: 36.0652, lon: 136.2216 },
      { code: 19, name: '山梨県', city: '甲府', lat: 35.6642, lon: 138.5684 },
      { code: 20, name: '長野県', city: '長野', lat: 36.6513, lon: 138.1810 },
      { code: 21, name: '岐阜県', city: '岐阜', lat: 35.3912, lon: 136.7223 },
      { code: 22, name: '静岡県', city: '静岡', lat: 34.9769, lon: 138.3831 },
      { code: 23, name: '愛知県', city: '名古屋', lat: 35.1815, lon: 136.9066 },
      { code: 24, name: '三重県', city: '津', lat: 34.7303, lon: 136.5086 },
      { code: 25, name: '滋賀県', city: '大津', lat: 35.0045, lon: 135.8686 },
      { code: 26, name: '京都府', city: '京都', lat: 35.0116, lon: 135.7681 },
      { code: 27, name: '大阪府', city: '大阪', lat: 34.6937, lon: 135.5023 },
      { code: 28, name: '兵庫県', city: '神戸', lat: 34.6901, lon: 135.1955 },
      { code: 29, name: '奈良県', city: '奈良', lat: 34.6851, lon: 135.8329 },
      { code: 30, name: '和歌山県', city: '和歌山', lat: 34.2261, lon: 135.1675 },
      { code: 31, name: '鳥取県', city: '鳥取', lat: 35.5014, lon: 134.2382 },
      { code: 32, name: '島根県', city: '松江', lat: 35.4723, lon: 133.0505 },
      { code: 33, name: '岡山県', city: '岡山', lat: 34.6617, lon: 133.9350 },
      { code: 34, name: '広島県', city: '広島', lat: 34.3965, lon: 132.4596 },
      { code: 35, name: '山口県', city: '山口', lat: 34.1861, lon: 131.4706 },
      { code: 36, name: '徳島県', city: '徳島', lat: 34.0658, lon: 134.5594 },
      { code: 37, name: '香川県', city: '高松', lat: 34.3401, lon: 134.0434 },
      { code: 38, name: '愛媛県', city: '松山', lat: 33.8416, lon: 132.7657 },
      { code: 39, name: '高知県', city: '高知', lat: 33.5597, lon: 133.5311 },
      { code: 40, name: '福岡県', city: '福岡', lat: 33.6064, lon: 130.4181 },
      { code: 41, name: '佐賀県', city: '佐賀', lat: 33.2494, lon: 130.2988 },
      { code: 42, name: '長崎県', city: '長崎', lat: 32.7503, lon: 129.8777 },
      { code: 43, name: '熊本県', city: '熊本', lat: 32.7898, lon: 130.7417 },
      { code: 44, name: '大分県', city: '大分', lat: 33.2382, lon: 131.6126 },
      { code: 45, name: '宮崎県', city: '宮崎', lat: 31.9077, lon: 131.4202 },
      { code: 46, name: '鹿児島県', city: '鹿児島', lat: 31.5602, lon: 130.5581 },
      { code: 47, name: '沖縄県', city: '那覇', lat: 26.2124, lon: 127.6809 }
    ];

    // geology classes (代表Vs 等)
    const geologyClasses = [
      { key:'A', name:'人工盛土・埋立', vs_rep:60, vs_min:30, vs_max:120, thickness:6 },
      { key:'B', name:'軟泥・粘性土', vs_rep:100, vs_min:50, vs_max:180, thickness:12 },
      { key:'C', name:'緩い砂・シルト', vs_rep:150, vs_min:100, vs_max:250, thickness:15 },
      { key:'D', name:'締まった砂・シルト', vs_rep:300, vs_min:200, vs_max:400, thickness:20 },
      { key:'E', name:'洪積台地・硬め堆積', vs_rep:450, vs_min:320, vs_max:700, thickness:40 },
      { key:'F', name:'砂礫・礫層', vs_rep:900, vs_min:600, vs_max:1500, thickness:60 },
      { key:'G', name:'硬岩（浅部）', vs_rep:2000, vs_min:1200, vs_max:3000, thickness:200 },
      { key:'H', name:'深層基盤（硬質）', vs_rep:3000, vs_min:2000, vs_max:5000, thickness:1000 }
    ];

    function findGeologyClassByAvs(avs) {
      if (avs < 120) return geologyClasses[0];
      if (avs < 180) return geologyClasses[1];
      if (avs < 260) return geologyClasses[2];
      if (avs < 360) return geologyClasses[3];
      if (avs < 700) return geologyClasses[4];
      if (avs < 1200) return geologyClasses[5];
      if (avs < 2000) return geologyClasses[6];
      return geologyClasses[7];
    }

    // 基本ユーティリティ（距離等）
    function toRad(deg){return deg*Math.PI/180;}
    function calculateDistance(lat1, lon1, lat2, lon2){
      const latAvg = (lat1+lat2)/2;
      const a=6378137, b=6356752.314245;
      const e2=(a*a-b*b)/(a*a);
      const W=Math.sqrt(1-e2*Math.sin(toRad(latAvg))**2);
      const M=(a*(1-e2))/(W**3);
      const N=a/W;
      const dLat=toRad(lat2-lat1);
      const dLon=toRad(lon2-lon1);
      const distance=Math.sqrt((M*dLat)**2 + (N*Math.cos(toRad(latAvg))*dLon)**2);
      return distance/1000;
    }
    function calculateHypocentralDistance(surfaceDistanceKm, depthKm){ return Math.sqrt(surfaceDistanceKm**2 + depthKm**2); }

    // PGV->震度
    function predictPGV(M, X, depth) {
      const Mw = M;
      const D = Math.max(X, 0.5);
      const depthFactor = 0.0038 * depth;
      const term = D + 0.0028 * Math.pow(10, 0.5 * Mw);
      const safeTerm = Math.max(term, 1e-6);
      const logPGV = 0.58 * Mw + depthFactor - 1.29 - Math.log10(safeTerm) - 0.002 * D;
      return Math.pow(10, logPGV);
    }
    function pgvToIntensity(pgv, amplification) {
      const adjustedPGV = Math.max(pgv * amplification, 1e-6);
      const I = 2.68 + 1.72 * Math.log10(adjustedPGV);
      return Math.max(0, I);
    }

    // GeoTIFF sampling (GSJ) - placeholder URL
    const GSJ_AVS30_TIF_URL = 'https://gbank.gsj.jp/whatever/avs30.tif';
    const _geoCache = {};
    async function fetchArrayBuffer(url){
      const r = await fetch(url);
      if(!r.ok) throw new Error('fetch failed: ' + r.status);
      return await r.arrayBuffer();
    }
    async function loadGeoTiffFromUrl(url){
      if (_geoCache[url]) return _geoCache[url];
      const ab = await fetchArrayBuffer(url);
      const tiff = await GeoTIFF.fromArrayBuffer(ab);
      const image = await tiff.getImage();
      const width = image.getWidth();
      const height = image.getHeight();
      const rasters = await image.readRasters({ interleave: true });
      const fileDir = image.getFileDirectory();
      let geoTransform = null;
      if (fileDir.ModelPixelScale && fileDir.ModelTiepoint) {
        const scale = fileDir.ModelPixelScale;
        const tie = fileDir.ModelTiepoint;
        const gt0 = tie[3], gt3 = tie[4];
        geoTransform = [gt0, scale[0], 0, gt3, 0, -scale[1]];
      }
      const res = { image, rasters, width, height, geoTransform, fileDir };
      _geoCache[url] = res;
      return res;
    }
    function worldToPixel(lon, lat, geoTransform){
      const GT = geoTransform;
      const x = (lon - GT[0]) / GT[1];
      const y = (lat - GT[3]) / GT[5];
      return { x, y };
    }
    function bilinearSample(rasters, width, height, x, y){
      if(x < 0 || y < 0 || x >= width-1 || y >= height-1) return null;
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const x1 = x0 + 1, y1 = y0 + 1;
      const f00 = rasters[y0 * width + x0];
      const f10 = rasters[y0 * width + x1];
      const f01 = rasters[y1 * width + x0];
      const f11 = rasters[y1 * width + x1];
      const dx = x - x0, dy = y - y0;
      const r0 = f00 * (1-dx) + f10 * dx;
      const r1 = f01 * (1-dx) + f11 * dx;
      return r0 * (1-dy) + r1 * dy;
    }
    async function getVs30FromGSJ(lat, lon, options = {}) {
      const url = options.url || GSJ_AVS30_TIF_URL;
      try {
        const cache = await loadGeoTiffFromUrl(url);
        if (!cache.geoTransform) throw new Error('no geoTransform');
        const pix = worldToPixel(lon, lat, cache.geoTransform);
        const val = bilinearSample(cache.rasters, cache.width, cache.height, pix.x, pix.y);
        if (val === null || isNaN(val)) return null;
        return val;
      } catch (e) {
        console.warn('GSJ sampling failed:', e && e.message);
        return null;
      }
    }

    /* ---------------------------
       深さ依存 Vs 実装のコア方針
       - buildLayersFromClass で浅層〜深層までの層を生成
       - 深さ200 mを閾値として、以降の深部層は "深部増速" を適用
       - deriveCrustVsFromLayers で層ごとに深さに応じた重み付けを行い、全体のクラスト速度を算出
       --------------------------- */

    // build layer stack from class and AVS30 (same logic as前と同様)
    function buildLayersFromClass(cls, avs30){
      const layers = [];
      if (avs30 && avs30 > 0) {
        const topVs = Math.max(40, Math.min(avs30, cls.vs_max || cls.vs_rep));
        layers.push({ thickness_m:5, vs_mps: Math.max(30, topVs * 0.7) });
        layers.push({ thickness_m:10, vs_mps: Math.max(60, topVs * 0.9) });
        layers.push({ thickness_m:15, vs_mps: Math.max(100, topVs) });
        const deeperThickness = Math.max(0, cls.thickness - 30);
        if (deeperThickness > 0) layers.push({ thickness_m: deeperThickness, vs_mps: cls.vs_rep });
      } else {
        layers.push({ thickness_m: Math.max(1, Math.round(cls.thickness*0.2)), vs_mps: Math.max(30, cls.vs_rep*0.6) });
        layers.push({ thickness_m: Math.max(1, Math.round(cls.thickness*0.3)), vs_mps: Math.max(60, cls.vs_rep*0.85) });
        layers.push({ thickness_m: Math.max(1, Math.round(cls.thickness*0.5)), vs_mps: cls.vs_rep });
      }
      // append deeper layers to represent upper crust -> lower crust trend
      // we append multiple deep slabs so cumulative > 200m can occur
      layers.push({ thickness_m: 100, vs_mps: Math.max(cls.vs_rep*1.2, 600) });
      layers.push({ thickness_m: 300, vs_mps: Math.max(cls.vs_rep*1.5, 1000) });
      layers.push({ thickness_m: 1000, vs_mps: Math.max(cls.vs_rep*1.8, 2000) });
      return layers;
    }

    // deep-boost: 深さ200m以降で vs を段階的に増やす
    function applyDepthDependentBoost(layers, boostStartDepth = 200){
      let cum = 0;
      const boosted = layers.map(L=>{
        const top = cum;
        const bottom = cum + L.thickness_m;
        cum = bottom;
        // if entire layer is shallower than boostStart -> no boost
        if (bottom <= boostStartDepth) return Object.assign({}, L);
        // if layer entirely below boostStart -> full boost
        if (top >= boostStartDepth) {
          // boost factor: 深さが深いほど大きく、底で最大 (例: 1.0 -> 1.6)
          const depthMid = (top + bottom) / 2;
          const factor = 1.0 + Math.min(1.0, (depthMid - boostStartDepth) / 800) * 0.6;
          return { thickness_m: L.thickness_m, vs_mps: L.vs_mps * factor };
        }
        // if partially crossing boostStartDepth: split into two pseudo-layers
        const shallowPart = boostStartDepth - top;
        const deepPart = bottom - boostStartDepth;
        const shallow = { thickness_m: shallowPart, vs_mps: L.vs_mps };
        const depthMid = boostStartDepth + deepPart / 2;
        const factor = 1.0 + Math.min(1.0, (depthMid - boostStartDepth) / 800) * 0.6;
        const deep = { thickness_m: deepPart, vs_mps: L.vs_mps * factor };
        return [shallow, deep];
      });
      // flatten arrays
      return boosted.flat();
    }

    // derive crust Vs from layers (weighted harmonic mean) using depth-boosted layers
    function deriveCrustVsFromLayersWithDepthBoost(layers){
      const boosted = applyDepthDependentBoost(layers, 200); // 200m 閾値
      let totalThickness=0, travelTime=0;
      for (const L of boosted){
        const H = Math.max(0.01, L.thickness_m);
        totalThickness += H;
        travelTime += H / Math.max(1, L.vs_mps);
      }
      if (travelTime <= 0) return 3.5;
      const avgVs_mps = totalThickness / travelTime;
      return Math.max(200, Math.min(6000, avgVs_mps)) / 1000;
    }

    // Arrival time using depth-boosted crustVs and top layer travel time
    function calculateSWaveArrivalTimeUsingLayersWithDepthBoost(distanceKm, depthKm, layers){
      const boosted = applyDepthDependentBoost(layers, 200);
      const crustVs_km = deriveCrustVsFromLayersWithDepthBoost(layers);
      const surfaceThicknessKm = (boosted[0] && boosted[0].thickness_m) ? boosted[0].thickness_m/1000 : 0.03;
      const hypoDistKm = calculateHypocentralDistance(distanceKm, depthKm);
      const surfaceVs_mps = boosted[0] ? Math.max(60, boosted[0].vs_mps) : 300;
      const surfaceTime = surfaceThicknessKm / (surfaceVs_mps / 1000);
      const crustTime = Math.max(0, (hypoDistKm - surfaceThicknessKm) / crustVs_km);
      return surfaceTime + crustTime;
    }

    // simple site amplification as earlier (keeps same)
    function computeLayerFundamentalFreq(layer){
      const H = Math.max(0.5, layer.thickness_m);
      return (layer.vs_mps) / (4 * H);
    }
    function computeSiteAmplification(layers, freqs=[0.5,1.0,2.0]){
      const Vs_ref = 760;
      const amps = freqs.map(f => {
        let resonanceSum = 0, weightSum = 0;
        for (const L of layers) {
          const H = Math.max(0.1, L.thickness_m);
          const f0 = computeLayerFundamentalFreq(L);
          const Q = 8;
          const lorentz = 1 / (1 + ((f - f0)/(f0/Q + 1e-6))**2);
          const stiffnessRatio = Math.sqrt(Vs_ref / Math.max(50, L.vs_mps));
          const thicknessWeight = Math.min(3, H / 10);
          const contrib = (1 + stiffnessRatio * lorentz * thicknessWeight);
          resonanceSum += contrib * thicknessWeight;
          weightSum += thicknessWeight;
        }
        if (weightSum > 0) resonanceSum = resonanceSum / weightSum;
        const topVs = layers.length ? layers[0].vs_mps : Vs_ref;
        const vs30Factor = Math.pow(Vs_ref / Math.max(60, Math.min(2000, topVs)), 0.35);
        let amp = resonanceSum * vs30Factor;
        amp = Math.min(Math.max(amp, 0.6), 6.0);
        return amp;
      });
      const weights = [0.3,0.5,0.2];
      let a=0,w=0;
      for (let i=0;i<amps.length;i++){ a += amps[i]*weights[i]; w += weights[i]; }
      const ampScalar = a/w;
      return { amps, freqs, ampScalar };
    }

    /* --------------------------
       App (UI + simulation)
       -------------------------- */
    function App(){
      const [magnitude, setMagnitude] = useState(7.0);
      const [depth, setDepth] = useState(10);
      const [epicPref, setEpicPref] = useState(13);
      const [targetPref, setTargetPref] = useState(14);
      const [epicenterLat, setEpicenterLat] = useState(35.6895);
      const [epicenterLon, setEpicenterLon] = useState(139.6917);
      const [targetLat, setTargetLat] = useState(35.4437);
      const [targetLon, setTargetLon] = useState(139.6380);
      const [useGSJ, setUseGSJ] = useState(true);
      const [autoAmplification, setAutoAmplification] = useState(true);
      const [avs30Val, setAvs30Val] = useState(300);
      const [geoClass, setGeoClass] = useState(geologyClasses[4]);
      const [ampFactor, setAmpFactor] = useState(1.4);
      const [predicted, setPredicted] = useState(null);
      const [prefIntensities, setPrefIntensities] = useState({});
      const [japanData, setJapanData] = useState(null);
      const [simTime, setSimTime] = useState(0);
      const [simSpeed, setSimSpeed] = useState(1);
      const [isSimulating, setIsSimulating] = useState(false);
      const svgRef = useRef(null);
      const animRef = useRef(null);

      useEffect(()=>{ const p = prefectures.find(pp=>pp.code===epicPref); if(p){ setEpicenterLat(p.lat); setEpicenterLon(p.lon); } }, [epicPref]);
      useEffect(()=>{ const p = prefectures.find(pp=>pp.code===targetPref); if(p){ setTargetLat(p.lat); setTargetLon(p.lon); } }, [targetPref]);

      // load geojson
      useEffect(()=>{
        let mounted=true;
        (async ()=>{
          const sources = [
            'https://raw.githubusercontent.com/niiyz/JapanCityGeoJson/master/geojson/prefectures.json',
            'https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson'
          ];
          let data = null;
          for (const s of sources){
            try{ const r = await fetch(s); if (r.ok) { data = await r.json(); break; } } catch(e){ console.warn('geo load failed', s); }
          }
          if (!data){
            data = { type:'FeatureCollection', features: prefectures.map(pref => {
              const pts=[]; const radius=0.45;
              for (let i=0;i<=360;i+=10){ const rad=i*Math.PI/180; const lat=pref.lat + radius*Math.sin(rad); const lon=pref.lon + radius*Math.cos(rad); pts.push([lon,lat]); }
              return { type:'Feature', properties:{name:pref.name}, geometry:{type:'Polygon', coordinates:[pts]} };
            })};
          }
          if (mounted) setJapanData(data);
        })();
        return ()=>{ mounted=false; }
      }, []);

      // resolve AVS30/class + compute amplification on target change
      useEffect(()=>{
        let cancelled=false;
        async function resolve(){
          if (!autoAmplification) return;
          let vs = null;
          if (useGSJ) {
            try { vs = await getVs30FromGSJ(targetLat, targetLon); } catch(e){ vs = null; }
          }
          if (vs === null || isNaN(vs)) {
            const est = estimateAVS30FromLocation(targetLat, targetLon);
            vs = est.avs30;
            const cls = findGeologyClassByAvs(vs);
            setGeoClass(cls);
            const layers = buildLayersFromClass(cls, vs);
            const boosted = applyDepthDependentBoost(layers, 200);
            const site = computeSiteAmplification(boosted);
            if (!cancelled) { setAvs30Val(Math.round(vs)); setAmpFactor(site.ampScalar); }
          } else {
            const cls = findGeologyClassByAvs(vs);
            setGeoClass(cls);
            const layers = buildLayersFromClass(cls, vs);
            const boosted = applyDepthDependentBoost(layers, 200);
            const site = computeSiteAmplification(boosted);
            if (!cancelled) { setAvs30Val(Math.round(vs)); setAmpFactor(site.ampScalar); }
          }
        }
        resolve();
        return ()=>{ cancelled = true; }
      }, [targetLat, targetLon, autoAmplification, useGSJ]);

      // point prediction update
      useEffect(()=>{
        const surfDist = calculateDistance(epicenterLat, epicenterLon, targetLat, targetLon);
        const hypo = calculateHypocentralDistance(surfDist, depth);
        const pgv = predictPGV(magnitude, hypo, depth);
        const intensity = pgvToIntensity(pgv, ampFactor);
        setPredicted({ value:intensity, scale:getIntensityScale(intensity), pgv, surfaceDistance:surfDist, hypoDistance:hypo });
      }, [magnitude, depth, epicenterLat, epicenterLon, targetLat, targetLon, ampFactor]);

      // svg draw
      useEffect(()=>{
        if (!japanData) return;
        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();
        const width=900, height=720;
        svg.attr('viewBox','0 0 '+width+' '+height);
        svg.append('rect').attr('width',width).attr('height',height).attr('fill','#e8f4f8');
        const projection = d3.geoMercator().center([137,38]).scale(1450).translate([width/2,height/2]);
        const path = d3.geoPath().projection(projection);
        const g = svg.append('g');

        g.selectAll('path').data(japanData.features).enter().append('path')
          .attr('d', path)
          .attr('fill', d => {
            const prefName = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
            const intensity = prefIntensities[prefName];
            return intensity ? (getIntensityColor(intensity.scale)) : '#f7fafc';
          })
          .attr('stroke','#333').attr('stroke-width',0.4)
          .attr('opacity', d => {
            const prefName = d.properties.name || d.properties.nam_ja || d.properties.name_ja;
            return prefIntensities[prefName] ? 0.95 : 0.65;
          });

        prefectures.forEach(pref => {
          const intensity = prefIntensities[pref.name];
          const coords = projection([pref.lon, pref.lat]);
          g.append('circle')
            .attr('cx', coords[0])
            .attr('cy', coords[1])
            .attr('r', intensity ? 4 : 2.5)
            .attr('fill', intensity ? getIntensityColor(intensity.scale) : '#666')
            .attr('stroke', '#fff')
            .attr('stroke-width', 0.8);

          if (intensity) {
            g.append('text')
              .attr('x', coords[0])
              .attr('y', coords[1] - 8)
              .attr('text-anchor','middle')
              .attr('font-weight','600')
              .attr('font-size','11px')
              .attr('fill', getIntensityColor(intensity.scale))
              .text(intensity.scale);
          }
        });

        const epicCoords = projection([epicenterLon, epicenterLat]);
        g.append('circle')
          .attr('cx', epicCoords[0])
          .attr('cy', epicCoords[1])
          .attr('r', 6)
          .attr('fill', '#ff3333')
          .attr('stroke', '#fff')
          .attr('stroke-width', 1.6);

        g.append('text')
          .attr('x', epicCoords[0])
          .attr('y', epicCoords[1] - 12)
          .attr('text-anchor','middle')
          .attr('font-weight','700')
          .attr('font-size','12px')
          .attr('fill','#ff3333')
          .text('震源');
      }, [japanData, prefIntensities, epicenterLat, epicenterLon]);

      // compute intensities for all prefs (async)
      async function calcAllPrefIntensitiesAsync(currentTimeSec) {
        const out = {};
        const promises = prefectures.map(async pref => {
          let vs = null;
          if (useGSJ) {
            try { vs = await getVs30FromGSJ(pref.lat, pref.lon); } catch(e){ vs = null; }
          }
          if (vs === null || isNaN(vs)) {
            const est = estimateAVS30FromLocation(pref.lat, pref.lon);
            vs = est.avs30;
            const cls = findGeologyClassByAvs(vs);
            const layers = buildLayersFromClass(cls, vs);
            return { pref, vs: Math.round(vs), cls, layers };
          } else {
            const cls = findGeologyClassByAvs(vs);
            const layers = buildLayersFromClass(cls, vs);
            return { pref, vs: Math.round(vs), cls, layers };
          }
        });
        const resolved = await Promise.all(promises);
        for (const item of resolved) {
          const pref = item.pref;
          const prefGeo = { avs30: item.vs, classObj: item.cls, layers: item.layers };
          const d = calculateDistance(epicenterLat, epicenterLon, pref.lat, pref.lon);
          const arrival = calculateSWaveArrivalTimeUsingLayersWithDepthBoost(d, depth, prefGeo.layers);
          if (currentTimeSec >= arrival) {
            const hypo = calculateHypocentralDistance(d, depth);
            const boosted = applyDepthDependentBoost(prefGeo.layers, 200);
            const site = computeSiteAmplification(boosted);
            const pgv = predictPGV(magnitude, hypo, depth);
            const intensity = pgvToIntensity(pgv, site.ampScalar);
            out[pref.name] = {
              value: intensity,
              scale: getIntensityScale(intensity),
              arrivalTime: arrival,
              distance: d,
              avs30: prefGeo.avs30,
              class: prefGeo.classObj.name,
              vs_rep: prefGeo.classObj.vs_rep,
              crustVs_km: deriveCrustVsFromLayersWithDepthBoost(prefGeo.layers)
            };
          }
        }
        return out;
      }

      function startSim(){
        if (isSimulating) return;
        setIsSimulating(true);
        const t0 = performance.now();
        async function loop(){
          const elapsed = (performance.now() - t0)/1000;
          const t = elapsed * simSpeed;
          setSimTime(t);
          const ints = await calcAllPrefIntensitiesAsync(t);
          setPrefIntensities(ints);
          const maxD = Math.max(...prefectures.map(p=>calculateDistance(epicenterLat, epicenterLon, p.lat, p.lon)));
          const maxT = calculateSWaveArrivalTimeUsingLayersWithDepthBoost(maxD, depth, [{thickness_m:30,vs_mps:600},{thickness_m:1000,vs_mps:3000}]);
          if (t < maxT + 8) { animRef.current = requestAnimationFrame(loop); }
          else { setIsSimulating(false); }
        }
        animRef.current = requestAnimationFrame(loop);
      }
      function stopSim(){ setIsSimulating(false); if (animRef.current) cancelAnimationFrame(animRef.current); }
      function resetSim(){ stopSim(); setSimTime(0); setPrefIntensities({}); }

      // initial target compute
      useEffect(()=> {
        let mounted=true;
        (async()=>{
          if (!autoAmplification) return;
          let vs = null;
          if (useGSJ) { try { vs = await getVs30FromGSJ(targetLat, targetLon); } catch(e){ vs = null; } }
          if (vs === null || isNaN(vs)) {
            const est = estimateAVS30FromLocation(targetLat, targetLon);
            vs = est.avs30;
            const cls = findGeologyClassByAvs(vs);
            const layers = buildLayersFromClass(cls, vs);
            const boosted = applyDepthDependentBoost(layers, 200);
            const site = computeSiteAmplification(boosted);
            if (mounted) { setAvs30Val(Math.round(vs)); setGeoClass(cls); setAmpFactor(site.ampScalar); }
          } else {
            const cls = findGeologyClassByAvs(vs);
            const layers = buildLayersFromClass(cls, vs);
            const boosted = applyDepthDependentBoost(layers, 200);
            const site = computeSiteAmplification(boosted);
            if (mounted) { setAvs30Val(Math.round(vs)); setGeoClass(cls); setAmpFactor(site.ampScalar); }
          }
        })();
        return ()=>{ mounted=false; }
      }, []);

      const currentLayers = buildLayersFromClass(geoClass, avs30Val);
      const boostedCurrent = applyDepthDependentBoost(currentLayers, 200);
      const siteDetail = computeSiteAmplification(boostedCurrent);
      const crustVs_display = deriveCrustVsFromLayersWithDepthBoost(currentLayers);

      // UI
      return html`
      <div class="min-h-screen">
        <div class="max-w-7xl mx-auto">
          <div class="bg-white rounded-lg shadow-xl p-6 mb-6">
            <div class="flex items-center gap-3 mb-4">
              <span>${Icon('activity',{width:32})}</span>
              <h1 class="text-3xl font-bold text-gray-800">震度予測（深さ依存 Vs 実装）</h1>
            </div>
            <p class="text-gray-600 mb-2">深さ200mを閾値に、深部で S 波速度を段階的に増加させる近似を実装しました。GSJ の AVS30 を利用可能なら優先して使用します。</p>
          </div>

          <div class="grid lg:grid-cols-3 gap-6 mb-6">
            <div class="bg-white rounded-lg shadow-lg p-6">
              <div class="flex items-center gap-2 mb-4"><span>${Icon('map-pin')}</span><h2 class="text-xl font-bold text-gray-800">震源と観測点</h2></div>
              <div class="space-y-3">
                <div>
                  <label class="block text-sm text-gray-700">マグニチュード: <strong>${magnitude.toFixed(1)}</strong></label>
                  <input type="range" min="4.0" max="9.0" step="0.1" value=${magnitude} onInput=${e=>setMagnitude(parseFloat(e.target.value))} class="w-full"/>
                </div>

                <div>
                  <label class="block text-sm text-gray-700">震源深さ (km): <strong>${depth}</strong></label>
                  <input type="range" min="0" max="100" step="1" value=${depth} onInput=${e=>setDepth(parseInt(e.target.value))} class="w-full"/>
                </div>

                <div>
                  <label class="block text-sm text-gray-700">震源 都道府県</label>
                  <select class="w-full px-2 py-1 border rounded text-sm" value=${epicPref} onChange=${e=>setEpicPref(parseInt(e.target.value))}>
                    ${prefectures.map(p=> html`<option value=${p.code}>${p.name} (${p.city})</option>`)}
                  </select>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div><label class="block text-sm text-gray-700">震源 緯度</label><input type="number" step="0.0001" value=${epicenterLat} onInput=${e=>setEpicenterLat(parseFloat(e.target.value))} class="w-full px-2 py-1 border rounded text-sm"/></div>
                  <div><label class="block text-sm text-gray-700">震源 経度</label><input type="number" step="0.0001" value=${epicenterLon} onInput=${e=>setEpicenterLon(parseFloat(e.target.value))} class="w-full px-2 py-1 border rounded text-sm"/></div>
                </div>

                <div><label class="block text-sm text-gray-700">観測点 都道府県</label><select class="w-full px-2 py-1 border rounded text-sm" value=${targetPref} onChange=${e=>setTargetPref(parseInt(e.target.value))}>${prefectures.map(p=> html`<option value=${p.code}>${p.name} (${p.city})</option>`)}</select></div>

                <div class="grid grid-cols-2 gap-2">
                  <div><label class="block text-sm text-gray-700">観測点 緯度</label><input type="number" step="0.0001" value=${targetLat} onInput=${e=>{ setTargetLat(parseFloat(e.target.value)); }} class="w-full px-2 py-1 border rounded text-sm"/></div>
                  <div><label class="block text-sm text-gray-700">観測点 経度</label><input type="number" step="0.0001" value=${targetLon} onInput=${e=>{ setTargetLon(parseFloat(e.target.value)); }} class="w-full px-2 py-1 border rounded text-sm"/></div>
                </div>

                <div class="border-t pt-3">
                  <div class="flex items-center justify-between mb-2">
                    <label class="text-sm font-medium text-gray-700">高精度モード（GSJ AVS30 利用）</label>
                    <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" checked=${useGSJ} onChange=${e=>setUseGSJ(e.target.checked)} class="sr-only"/><div class=${'switch ' + (useGSJ ? 'on' : '')}><div class="knob"></div></div></label>
                  </div>
                  <div class="flex items-center justify-between mb-2">
                    <label class="text-sm font-medium text-gray-700">地層自動計算</label>
                    <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" checked=${autoAmplification} onChange=${e=>setAutoAmplification(e.target.checked)} class="sr-only"/><div class=${'switch ' + (autoAmplification ? 'on' : '')}><div class="knob"></div></div></label>
                  </div>

                  <div class="bg-green-50 p-3 rounded-md text-sm">
                    <p class="text-green-800 font-medium">地層クラス: ${geoClass.key} — ${geoClass.name}</p>
                    <p class="text-green-800">AVS30: <span class="mono">${avs30Val}</span> m/s</p>
                    <p class="text-green-800">代表Vs (top): ${geoClass.vs_rep} m/s</p>
                    <p class="text-green-800">深部速度増加閾値: 200 m</p>
                    <p class="text-green-800">推定上部地殻 Vs: <span class="mono">${crustVs_display.toFixed(2)}</span> km/s</p>
                    <p class="text-green-800">増幅合成 (0.5/1/2Hz): ${siteDetail.amps.map(a=>a.toFixed(2)).join(' / ')}</p>
                    <p class="text-green-800">増幅率（PGV 用合成）: ${siteDetail.ampScalar.toFixed(2)}</p>
                  </div>
                </div>

              </div>
            </div>

            <div class="bg-white rounded-lg shadow-lg p-6">
              <h2 class="text-xl font-bold mb-3">地点予測結果</h2>
              ${predicted ? html`
                <div style="background-color:${getIntensityColor(predicted.scale)}20" class="rounded-lg p-4 text-center mb-3">
                  <div class="text-5xl font-bold" style="color:${getIntensityColor(predicted.scale)}">${predicted.scale}</div>
                  <p class="text-sm text-gray-600 mt-1">計測震度: ${predicted.value.toFixed(2)}</p>
                </div>
                <div class="text-sm space-y-1">
                  <div class="flex justify-between"><span class="text-gray-600">震央距離:</span><span class="font-semibold">${predicted.surfaceDistance.toFixed(1)} km</span></div>
                  <div class="flex justify-between"><span class="text-gray-600">予測PGV:</span><span class="font-semibold">${predicted.pgv.toFixed(2)} cm/s</span></div>
                </div>
              ` : html`<div class="text-sm text-gray-600">計算中...</div>`}
            </div>

            <div class="bg-white rounded-lg shadow-lg p-6">
              <h2 class="text-xl font-bold mb-3">地層クラス（代表Vs）</h2>
              <div class="text-sm text-gray-700">
                <table class="w-full text-xs">
                  <thead><tr><th class="text-left">Key</th><th class="text-left">Name</th><th class="text-left">Vs rep</th><th class="text-left">Range</th><th class="text-left">thickness</th></tr></thead>
                  <tbody>
                    ${geologyClasses.map(g=> html`<tr><td>${g.key}</td><td>${g.name}</td><td>${g.vs_rep}</td><td>${g.vs_min}–${g.vs_max}</td><td>${g.thickness} m</td></tr>`)}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="bg-white rounded-lg shadow-xl p-6 mb-6">
            <div class="flex justify-between items-center mb-4">
              <h2 class="text-2xl font-bold text-gray-800">日本地図 震度分布シミュレーション</h2>
              <div class="flex gap-2 items-center">
                <select value=${simSpeed} onChange=${e=>setSimSpeed(parseFloat(e.target.value))} class="px-3 py-2 border rounded text-sm">
                  <option value="1">1倍速</option>
                  <option value="2">2倍速</option>
                  <option value="5">5倍速</option>
                  <option value="10">10倍速</option>
                </select>
                <button onClick=${startSim} class="px-4 py-2 bg-blue-600 text-white rounded">${Icon('play')} 開始</button>
                <button onClick=${stopSim} class="px-4 py-2 bg-yellow-600 text-white rounded">${Icon('pause')} 停止</button>
                <button onClick=${resetSim} class="px-4 py-2 bg-gray-600 text-white rounded">${Icon('rotate-ccw')} リセット</button>
              </div>
            </div>

            <div class="bg-gray-100 rounded-lg p-4 mb-4">
              <div class="flex justify-between">
                <span class="text-lg font-semibold">経過時間: ${simTime.toFixed(1)} 秒</span>
                <span class="text-sm text-gray-600">到達地域数: ${Object.keys(prefIntensities).length} / 47</span>
              </div>
            </div>

            <div class="relative bg-white rounded-lg p-4 border">
              <div style="min-height:460px;">
                <svg id="svgMap" ref=${svgRef}></svg>
              </div>
            </div>

            <div class="grid md:grid-cols-2 gap-4 mt-4">
              <div class="bg-gray-50 rounded-lg p-4">
                <h3 class="font-bold mb-2">到達済み地域（到達順）</h3>
                <div class="space-y-1 max-h-64 overflow-y-auto text-xs">
                  ${Object.entries(prefIntensities).sort((a,b)=>a[1].arrivalTime-b[1].arrivalTime).map(([name,data]) => html`
                    <div class="flex justify-between items-center p-2 bg-white rounded text-xs">
                      <div>
                        <div class="font-medium">${name}</div>
                        <div class="small-label text-gray-500">${data.class} · AVS30:${data.avs30} m/s · Vs_rep:${data.vs_rep} m/s</div>
                      </div>
                      <div class="text-right">
                        <div class="text-gray-600">${data.arrivalTime.toFixed(1)} s</div>
                        <div style="background:${getIntensityColor(data.scale)}30;color:${getIntensityColor(data.scale)}" class="font-bold px-2 py-1 rounded">震度 ${data.scale}</div>
                      </div>
                    </div>
                  `)}
                </div>
              </div>

              <div class="bg-gray-50 rounded-lg p-4">
                <h3 class="font-bold mb-2">震度凡例</h3>
                <div class="grid grid-cols-2 gap-2">
                  ${['0','1','2','3','4','5弱','5強','6弱','6強','7'].map(scale => html`
                    <div class="flex items-center gap-2 p-2 bg-white rounded text-sm">
                      <div style="width:24px;height:24px;background:${getIntensityColor(scale)};border-radius:4px"></div>
                      <span>震度 ${scale}</span>
                    </div>`)}
                </div>
              </div>
            </div>
          </div>

          <div class="bg-white rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-bold mb-3">実装メモ（簡潔）</h3>
            <div class="text-sm text-gray-600">
              <ul class="list-disc list-inside">
                <li>文献傾向を踏まえ「浅層（数十 m）と深部（>200 m）」で S 波速度が異なる点を反映しました。</li>
                <li>閾値 200 m は実務上の目安です。地点資料（ボーリング・ Vs プロファイル）がある場合はそれで置き換えてください。</li>
                <li>GSJ の実データを使う場合は GSJ_AVS30_TIF_URL を実エンドポイントに差し替え、CORS を確認してください。</li>
                <li>さらに厳密な深部速度分布や層別Vsは現地観測・反射法などのデータで決める必要があります。必要なら 1D 精密伝達関数やGMPEの差し替えを行います。</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      `;
    }

    // フォールバック estimateAVS30FromLocation (既存)
    function estimateAVS30FromLocation(lat, lon) {
      const urbanCenters = [
        { lat:35.68, lon:139.76, radiusKm:50 },
        { lat:34.69, lon:135.50, radiusKm:40 },
        { lat:35.18, lon:136.91, radiusKm:30 },
        { lat:33.59, lon:130.40, radiusKm:40 }
      ];
      const isUrban = urbanCenters.some(c => {
        const d = calculateDistance(lat, lon, c.lat, c.lon);
        return d <= c.radiusKm;
      });

      const nearCoast = (lon > 122 && lon < 153 && (Math.abs(lat - 35) < 6 || Math.abs(lat - 33) < 6)) && (Math.abs(lon - 139.7) < 3 || lon < 132);
      const isLowland = (lat < 36 && lon > 138 && lon < 141) || (lat > 34 && lat < 35 && lon > 134 && lon < 136);
      const isAlluvial = (lat > 35 && lat < 37 && lon > 138.5 && lon < 140) || (lat > 33 && lat < 34 && lon > 130 && lon < 131);
      const isPlateau = (lat > 35.5 && lat < 36.5 && lon > 137 && lon < 140.5);
      const isMountain = (lat > 36 && lon < 139) || lat > 38 || lon < 132;

      let avs = 300;
      if (isMountain) avs = 450;
      else if (isPlateau) avs = 310;
      else if (isAlluvial) avs = 220;
      else if (isLowland) avs = 200;
      else if (nearCoast) avs = 180;
      if (isUrban) avs = Math.min(avs + 20, 350);
      avs += (35.5 - lat) * 2;
      avs = Math.max(80, Math.min(600, Math.round(avs)));
      const cls = findGeologyClassByAvs(avs);
      return { avs30: avs, type: cls.name, classKey: cls.key };
    }

    render(h(App, {}), document.getElementById('app'));
  })();
  </script>
</body>
</html>
